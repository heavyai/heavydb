#
# Autogenerated by Thrift Compiler (0.15.0)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py
#

from thrift.Thrift import TType, TMessageType, TFrozenDict, TException, TApplicationException
from thrift.protocol.TProtocol import TProtocolException
from thrift.TRecursive import fix_spec

import sys
import logging
from .ttypes import *
from thrift.Thrift import TProcessor
from thrift.transport import TTransport
all_structs = []


class Iface(object):
    def connect(self, user, passwd, dbname):
        """
        Parameters:
         - user
         - passwd
         - dbname

        """
        pass

    def krb5_connect(self, inputToken, dbname):
        """
        Parameters:
         - inputToken
         - dbname

        """
        pass

    def disconnect(self, session):
        """
        Parameters:
         - session

        """
        pass

    def switch_database(self, session, dbname):
        """
        Parameters:
         - session
         - dbname

        """
        pass

    def clone_session(self, session):
        """
        Parameters:
         - session

        """
        pass

    def get_server_status(self, session):
        """
        Parameters:
         - session

        """
        pass

    def get_status(self, session):
        """
        Parameters:
         - session

        """
        pass

    def get_hardware_info(self, session):
        """
        Parameters:
         - session

        """
        pass

    def get_tables(self, session):
        """
        Parameters:
         - session

        """
        pass

    def get_tables_for_database(self, session, database_name):
        """
        Parameters:
         - session
         - database_name

        """
        pass

    def get_physical_tables(self, session):
        """
        Parameters:
         - session

        """
        pass

    def get_views(self, session):
        """
        Parameters:
         - session

        """
        pass

    def get_tables_meta(self, session):
        """
        Parameters:
         - session

        """
        pass

    def get_table_details(self, session, table_name):
        """
        Parameters:
         - session
         - table_name

        """
        pass

    def get_table_details_for_database(self, session, table_name, database_name):
        """
        Parameters:
         - session
         - table_name
         - database_name

        """
        pass

    def get_internal_table_details(self, session, table_name, include_system_columns):
        """
        Parameters:
         - session
         - table_name
         - include_system_columns

        """
        pass

    def get_internal_table_details_for_database(self, session, table_name, database_name):
        """
        Parameters:
         - session
         - table_name
         - database_name

        """
        pass

    def get_users(self, session):
        """
        Parameters:
         - session

        """
        pass

    def get_databases(self, session):
        """
        Parameters:
         - session

        """
        pass

    def get_version(self):
        pass

    def start_heap_profile(self, session):
        """
        Parameters:
         - session

        """
        pass

    def stop_heap_profile(self, session):
        """
        Parameters:
         - session

        """
        pass

    def get_heap_profile(self, session):
        """
        Parameters:
         - session

        """
        pass

    def get_memory(self, session, memory_level):
        """
        Parameters:
         - session
         - memory_level

        """
        pass

    def clear_cpu_memory(self, session):
        """
        Parameters:
         - session

        """
        pass

    def clear_gpu_memory(self, session):
        """
        Parameters:
         - session

        """
        pass

    def set_cur_session(self, parent_session, leaf_session, start_time_str, label, for_running_query_kernel):
        """
        Parameters:
         - parent_session
         - leaf_session
         - start_time_str
         - label
         - for_running_query_kernel

        """
        pass

    def invalidate_cur_session(self, parent_session, leaf_session, start_time_str, label, for_running_query_kernel):
        """
        Parameters:
         - parent_session
         - leaf_session
         - start_time_str
         - label
         - for_running_query_kernel

        """
        pass

    def set_table_epoch(self, session, db_id, table_id, new_epoch):
        """
        Parameters:
         - session
         - db_id
         - table_id
         - new_epoch

        """
        pass

    def set_table_epoch_by_name(self, session, table_name, new_epoch):
        """
        Parameters:
         - session
         - table_name
         - new_epoch

        """
        pass

    def get_table_epoch(self, session, db_id, table_id):
        """
        Parameters:
         - session
         - db_id
         - table_id

        """
        pass

    def get_table_epoch_by_name(self, session, table_name):
        """
        Parameters:
         - session
         - table_name

        """
        pass

    def get_table_epochs(self, session, db_id, table_id):
        """
        Parameters:
         - session
         - db_id
         - table_id

        """
        pass

    def set_table_epochs(self, session, db_id, table_epochs):
        """
        Parameters:
         - session
         - db_id
         - table_epochs

        """
        pass

    def get_session_info(self, session):
        """
        Parameters:
         - session

        """
        pass

    def get_queries_info(self, session):
        """
        Parameters:
         - session

        """
        pass

    def set_leaf_info(self, session, leaf_info):
        """
        Parameters:
         - session
         - leaf_info

        """
        pass

    def sql_execute(self, session, query, column_format, nonce, first_n, at_most_n):
        """
        Parameters:
         - session
         - query
         - column_format
         - nonce
         - first_n
         - at_most_n

        """
        pass

    def sql_execute_df(self, session, query, device_type, device_id, first_n, transport_method):
        """
        Parameters:
         - session
         - query
         - device_type
         - device_id
         - first_n
         - transport_method

        """
        pass

    def sql_execute_gdf(self, session, query, device_id, first_n):
        """
        Parameters:
         - session
         - query
         - device_id
         - first_n

        """
        pass

    def deallocate_df(self, session, df, device_type, device_id):
        """
        Parameters:
         - session
         - df
         - device_type
         - device_id

        """
        pass

    def interrupt(self, query_session, interrupt_session):
        """
        Parameters:
         - query_session
         - interrupt_session

        """
        pass

    def sql_validate(self, session, query):
        """
        Parameters:
         - session
         - query

        """
        pass

    def get_completion_hints(self, session, sql, cursor):
        """
        Parameters:
         - session
         - sql
         - cursor

        """
        pass

    def set_execution_mode(self, session, mode):
        """
        Parameters:
         - session
         - mode

        """
        pass

    def render_vega(self, session, widget_id, vega_json, compression_level, nonce):
        """
        Parameters:
         - session
         - widget_id
         - vega_json
         - compression_level
         - nonce

        """
        pass

    def get_result_row_for_pixel(self, session, widget_id, pixel, table_col_names, column_format, pixelRadius, nonce):
        """
        Parameters:
         - session
         - widget_id
         - pixel
         - table_col_names
         - column_format
         - pixelRadius
         - nonce

        """
        pass

    def create_custom_expression(self, session, custom_expression):
        """
        Parameters:
         - session
         - custom_expression

        """
        pass

    def get_custom_expressions(self, session):
        """
        Parameters:
         - session

        """
        pass

    def update_custom_expression(self, session, id, expression_json):
        """
        Parameters:
         - session
         - id
         - expression_json

        """
        pass

    def delete_custom_expressions(self, session, custom_expression_ids, do_soft_delete):
        """
        Parameters:
         - session
         - custom_expression_ids
         - do_soft_delete

        """
        pass

    def get_dashboard(self, session, dashboard_id):
        """
        Parameters:
         - session
         - dashboard_id

        """
        pass

    def get_dashboards(self, session):
        """
        Parameters:
         - session

        """
        pass

    def create_dashboard(self, session, dashboard_name, dashboard_state, image_hash, dashboard_metadata):
        """
        Parameters:
         - session
         - dashboard_name
         - dashboard_state
         - image_hash
         - dashboard_metadata

        """
        pass

    def replace_dashboard(self, session, dashboard_id, dashboard_name, dashboard_owner, dashboard_state, image_hash, dashboard_metadata):
        """
        Parameters:
         - session
         - dashboard_id
         - dashboard_name
         - dashboard_owner
         - dashboard_state
         - image_hash
         - dashboard_metadata

        """
        pass

    def delete_dashboard(self, session, dashboard_id):
        """
        Parameters:
         - session
         - dashboard_id

        """
        pass

    def share_dashboards(self, session, dashboard_ids, groups, permissions):
        """
        Parameters:
         - session
         - dashboard_ids
         - groups
         - permissions

        """
        pass

    def delete_dashboards(self, session, dashboard_ids):
        """
        Parameters:
         - session
         - dashboard_ids

        """
        pass

    def share_dashboard(self, session, dashboard_id, groups, objects, permissions, grant_role):
        """
        Parameters:
         - session
         - dashboard_id
         - groups
         - objects
         - permissions
         - grant_role

        """
        pass

    def unshare_dashboard(self, session, dashboard_id, groups, objects, permissions):
        """
        Parameters:
         - session
         - dashboard_id
         - groups
         - objects
         - permissions

        """
        pass

    def unshare_dashboards(self, session, dashboard_ids, groups, permissions):
        """
        Parameters:
         - session
         - dashboard_ids
         - groups
         - permissions

        """
        pass

    def get_dashboard_grantees(self, session, dashboard_id):
        """
        Parameters:
         - session
         - dashboard_id

        """
        pass

    def get_link_view(self, session, link):
        """
        Parameters:
         - session
         - link

        """
        pass

    def create_link(self, session, view_state, view_metadata):
        """
        Parameters:
         - session
         - view_state
         - view_metadata

        """
        pass

    def load_table_binary(self, session, table_name, rows, column_names):
        """
        Parameters:
         - session
         - table_name
         - rows
         - column_names

        """
        pass

    def load_table_binary_columnar(self, session, table_name, cols, column_names):
        """
        Parameters:
         - session
         - table_name
         - cols
         - column_names

        """
        pass

    def load_table_binary_columnar_polys(self, session, table_name, cols, column_names, assign_render_groups):
        """
        Parameters:
         - session
         - table_name
         - cols
         - column_names
         - assign_render_groups

        """
        pass

    def load_table_binary_arrow(self, session, table_name, arrow_stream, use_column_names):
        """
        Parameters:
         - session
         - table_name
         - arrow_stream
         - use_column_names

        """
        pass

    def load_table(self, session, table_name, rows, column_names):
        """
        Parameters:
         - session
         - table_name
         - rows
         - column_names

        """
        pass

    def detect_column_types(self, session, file_name, copy_params):
        """
        Parameters:
         - session
         - file_name
         - copy_params

        """
        pass

    def create_table(self, session, table_name, row_desc, create_params):
        """
        Parameters:
         - session
         - table_name
         - row_desc
         - create_params

        """
        pass

    def import_table(self, session, table_name, file_name, copy_params):
        """
        Parameters:
         - session
         - table_name
         - file_name
         - copy_params

        """
        pass

    def import_geo_table(self, session, table_name, file_name, copy_params, row_desc, create_params):
        """
        Parameters:
         - session
         - table_name
         - file_name
         - copy_params
         - row_desc
         - create_params

        """
        pass

    def import_table_status(self, session, import_id):
        """
        Parameters:
         - session
         - import_id

        """
        pass

    def get_first_geo_file_in_archive(self, session, archive_path, copy_params):
        """
        Parameters:
         - session
         - archive_path
         - copy_params

        """
        pass

    def get_all_files_in_archive(self, session, archive_path, copy_params):
        """
        Parameters:
         - session
         - archive_path
         - copy_params

        """
        pass

    def get_layers_in_geo_file(self, session, file_name, copy_params):
        """
        Parameters:
         - session
         - file_name
         - copy_params

        """
        pass

    def query_get_outer_fragment_count(self, session, query):
        """
        Parameters:
         - session
         - query

        """
        pass

    def check_table_consistency(self, session, table_id):
        """
        Parameters:
         - session
         - table_id

        """
        pass

    def start_query(self, leaf_session, parent_session, query_ra, start_time_str, just_explain, outer_fragment_indices):
        """
        Parameters:
         - leaf_session
         - parent_session
         - query_ra
         - start_time_str
         - just_explain
         - outer_fragment_indices

        """
        pass

    def execute_query_step(self, pending_query, subquery_id, start_time_str):
        """
        Parameters:
         - pending_query
         - subquery_id
         - start_time_str

        """
        pass

    def broadcast_serialized_rows(self, serialized_rows, row_desc, query_id, subquery_id, is_final_subquery_result):
        """
        Parameters:
         - serialized_rows
         - row_desc
         - query_id
         - subquery_id
         - is_final_subquery_result

        """
        pass

    def start_render_query(self, session, widget_id, node_idx, vega_json):
        """
        Parameters:
         - session
         - widget_id
         - node_idx
         - vega_json

        """
        pass

    def execute_next_render_step(self, pending_render, merged_data):
        """
        Parameters:
         - pending_render
         - merged_data

        """
        pass

    def insert_data(self, session, insert_data):
        """
        Parameters:
         - session
         - insert_data

        """
        pass

    def insert_chunks(self, session, insert_chunks):
        """
        Parameters:
         - session
         - insert_chunks

        """
        pass

    def checkpoint(self, session, table_id):
        """
        Parameters:
         - session
         - table_id

        """
        pass

    def get_roles(self, session):
        """
        Parameters:
         - session

        """
        pass

    def get_db_objects_for_grantee(self, session, roleName):
        """
        Parameters:
         - session
         - roleName

        """
        pass

    def get_db_object_privs(self, session, objectName, type):
        """
        Parameters:
         - session
         - objectName
         - type

        """
        pass

    def get_all_roles_for_user(self, session, userName):
        """
        Parameters:
         - session
         - userName

        """
        pass

    def get_all_effective_roles_for_user(self, session, userName):
        """
        Parameters:
         - session
         - userName

        """
        pass

    def has_role(self, session, granteeName, roleName):
        """
        Parameters:
         - session
         - granteeName
         - roleName

        """
        pass

    def has_object_privilege(self, session, granteeName, ObjectName, objectType, permissions):
        """
        Parameters:
         - session
         - granteeName
         - ObjectName
         - objectType
         - permissions

        """
        pass

    def set_license_key(self, session, key, nonce):
        """
        Parameters:
         - session
         - key
         - nonce

        """
        pass

    def get_license_claims(self, session, nonce):
        """
        Parameters:
         - session
         - nonce

        """
        pass

    def get_device_parameters(self, session):
        """
        Parameters:
         - session

        """
        pass

    def register_runtime_extension_functions(self, session, udfs, udtfs, device_ir_map):
        """
        Parameters:
         - session
         - udfs
         - udtfs
         - device_ir_map

        """
        pass

    def get_table_function_names(self, session):
        """
        Parameters:
         - session

        """
        pass

    def get_runtime_table_function_names(self, session):
        """
        Parameters:
         - session

        """
        pass

    def get_table_function_details(self, session, udtf_names):
        """
        Parameters:
         - session
         - udtf_names

        """
        pass


class Client(Iface):
    def __init__(self, iprot, oprot=None):
        self._iprot = self._oprot = iprot
        if oprot is not None:
            self._oprot = oprot
        self._seqid = 0

    def connect(self, user, passwd, dbname):
        """
        Parameters:
         - user
         - passwd
         - dbname

        """
        self.send_connect(user, passwd, dbname)
        return self.recv_connect()

    def send_connect(self, user, passwd, dbname):
        self._oprot.writeMessageBegin('connect', TMessageType.CALL, self._seqid)
        args = connect_args()
        args.user = user
        args.passwd = passwd
        args.dbname = dbname
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_connect(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = connect_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TApplicationException(TApplicationException.MISSING_RESULT, "connect failed: unknown result")

    def krb5_connect(self, inputToken, dbname):
        """
        Parameters:
         - inputToken
         - dbname

        """
        self.send_krb5_connect(inputToken, dbname)
        return self.recv_krb5_connect()

    def send_krb5_connect(self, inputToken, dbname):
        self._oprot.writeMessageBegin('krb5_connect', TMessageType.CALL, self._seqid)
        args = krb5_connect_args()
        args.inputToken = inputToken
        args.dbname = dbname
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_krb5_connect(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = krb5_connect_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TApplicationException(TApplicationException.MISSING_RESULT, "krb5_connect failed: unknown result")

    def disconnect(self, session):
        """
        Parameters:
         - session

        """
        self.send_disconnect(session)
        self.recv_disconnect()

    def send_disconnect(self, session):
        self._oprot.writeMessageBegin('disconnect', TMessageType.CALL, self._seqid)
        args = disconnect_args()
        args.session = session
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_disconnect(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = disconnect_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        return

    def switch_database(self, session, dbname):
        """
        Parameters:
         - session
         - dbname

        """
        self.send_switch_database(session, dbname)
        self.recv_switch_database()

    def send_switch_database(self, session, dbname):
        self._oprot.writeMessageBegin('switch_database', TMessageType.CALL, self._seqid)
        args = switch_database_args()
        args.session = session
        args.dbname = dbname
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_switch_database(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = switch_database_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        return

    def clone_session(self, session):
        """
        Parameters:
         - session

        """
        self.send_clone_session(session)
        return self.recv_clone_session()

    def send_clone_session(self, session):
        self._oprot.writeMessageBegin('clone_session', TMessageType.CALL, self._seqid)
        args = clone_session_args()
        args.session = session
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_clone_session(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = clone_session_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TApplicationException(TApplicationException.MISSING_RESULT, "clone_session failed: unknown result")

    def get_server_status(self, session):
        """
        Parameters:
         - session

        """
        self.send_get_server_status(session)
        return self.recv_get_server_status()

    def send_get_server_status(self, session):
        self._oprot.writeMessageBegin('get_server_status', TMessageType.CALL, self._seqid)
        args = get_server_status_args()
        args.session = session
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_server_status(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_server_status_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_server_status failed: unknown result")

    def get_status(self, session):
        """
        Parameters:
         - session

        """
        self.send_get_status(session)
        return self.recv_get_status()

    def send_get_status(self, session):
        self._oprot.writeMessageBegin('get_status', TMessageType.CALL, self._seqid)
        args = get_status_args()
        args.session = session
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_status(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_status_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_status failed: unknown result")

    def get_hardware_info(self, session):
        """
        Parameters:
         - session

        """
        self.send_get_hardware_info(session)
        return self.recv_get_hardware_info()

    def send_get_hardware_info(self, session):
        self._oprot.writeMessageBegin('get_hardware_info', TMessageType.CALL, self._seqid)
        args = get_hardware_info_args()
        args.session = session
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_hardware_info(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_hardware_info_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_hardware_info failed: unknown result")

    def get_tables(self, session):
        """
        Parameters:
         - session

        """
        self.send_get_tables(session)
        return self.recv_get_tables()

    def send_get_tables(self, session):
        self._oprot.writeMessageBegin('get_tables', TMessageType.CALL, self._seqid)
        args = get_tables_args()
        args.session = session
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_tables(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_tables_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_tables failed: unknown result")

    def get_tables_for_database(self, session, database_name):
        """
        Parameters:
         - session
         - database_name

        """
        self.send_get_tables_for_database(session, database_name)
        return self.recv_get_tables_for_database()

    def send_get_tables_for_database(self, session, database_name):
        self._oprot.writeMessageBegin('get_tables_for_database', TMessageType.CALL, self._seqid)
        args = get_tables_for_database_args()
        args.session = session
        args.database_name = database_name
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_tables_for_database(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_tables_for_database_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_tables_for_database failed: unknown result")

    def get_physical_tables(self, session):
        """
        Parameters:
         - session

        """
        self.send_get_physical_tables(session)
        return self.recv_get_physical_tables()

    def send_get_physical_tables(self, session):
        self._oprot.writeMessageBegin('get_physical_tables', TMessageType.CALL, self._seqid)
        args = get_physical_tables_args()
        args.session = session
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_physical_tables(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_physical_tables_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_physical_tables failed: unknown result")

    def get_views(self, session):
        """
        Parameters:
         - session

        """
        self.send_get_views(session)
        return self.recv_get_views()

    def send_get_views(self, session):
        self._oprot.writeMessageBegin('get_views', TMessageType.CALL, self._seqid)
        args = get_views_args()
        args.session = session
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_views(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_views_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_views failed: unknown result")

    def get_tables_meta(self, session):
        """
        Parameters:
         - session

        """
        self.send_get_tables_meta(session)
        return self.recv_get_tables_meta()

    def send_get_tables_meta(self, session):
        self._oprot.writeMessageBegin('get_tables_meta', TMessageType.CALL, self._seqid)
        args = get_tables_meta_args()
        args.session = session
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_tables_meta(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_tables_meta_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_tables_meta failed: unknown result")

    def get_table_details(self, session, table_name):
        """
        Parameters:
         - session
         - table_name

        """
        self.send_get_table_details(session, table_name)
        return self.recv_get_table_details()

    def send_get_table_details(self, session, table_name):
        self._oprot.writeMessageBegin('get_table_details', TMessageType.CALL, self._seqid)
        args = get_table_details_args()
        args.session = session
        args.table_name = table_name
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_table_details(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_table_details_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_table_details failed: unknown result")

    def get_table_details_for_database(self, session, table_name, database_name):
        """
        Parameters:
         - session
         - table_name
         - database_name

        """
        self.send_get_table_details_for_database(session, table_name, database_name)
        return self.recv_get_table_details_for_database()

    def send_get_table_details_for_database(self, session, table_name, database_name):
        self._oprot.writeMessageBegin('get_table_details_for_database', TMessageType.CALL, self._seqid)
        args = get_table_details_for_database_args()
        args.session = session
        args.table_name = table_name
        args.database_name = database_name
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_table_details_for_database(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_table_details_for_database_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_table_details_for_database failed: unknown result")

    def get_internal_table_details(self, session, table_name, include_system_columns):
        """
        Parameters:
         - session
         - table_name
         - include_system_columns

        """
        self.send_get_internal_table_details(session, table_name, include_system_columns)
        return self.recv_get_internal_table_details()

    def send_get_internal_table_details(self, session, table_name, include_system_columns):
        self._oprot.writeMessageBegin('get_internal_table_details', TMessageType.CALL, self._seqid)
        args = get_internal_table_details_args()
        args.session = session
        args.table_name = table_name
        args.include_system_columns = include_system_columns
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_internal_table_details(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_internal_table_details_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_internal_table_details failed: unknown result")

    def get_internal_table_details_for_database(self, session, table_name, database_name):
        """
        Parameters:
         - session
         - table_name
         - database_name

        """
        self.send_get_internal_table_details_for_database(session, table_name, database_name)
        return self.recv_get_internal_table_details_for_database()

    def send_get_internal_table_details_for_database(self, session, table_name, database_name):
        self._oprot.writeMessageBegin('get_internal_table_details_for_database', TMessageType.CALL, self._seqid)
        args = get_internal_table_details_for_database_args()
        args.session = session
        args.table_name = table_name
        args.database_name = database_name
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_internal_table_details_for_database(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_internal_table_details_for_database_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_internal_table_details_for_database failed: unknown result")

    def get_users(self, session):
        """
        Parameters:
         - session

        """
        self.send_get_users(session)
        return self.recv_get_users()

    def send_get_users(self, session):
        self._oprot.writeMessageBegin('get_users', TMessageType.CALL, self._seqid)
        args = get_users_args()
        args.session = session
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_users(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_users_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_users failed: unknown result")

    def get_databases(self, session):
        """
        Parameters:
         - session

        """
        self.send_get_databases(session)
        return self.recv_get_databases()

    def send_get_databases(self, session):
        self._oprot.writeMessageBegin('get_databases', TMessageType.CALL, self._seqid)
        args = get_databases_args()
        args.session = session
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_databases(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_databases_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_databases failed: unknown result")

    def get_version(self):
        self.send_get_version()
        return self.recv_get_version()

    def send_get_version(self):
        self._oprot.writeMessageBegin('get_version', TMessageType.CALL, self._seqid)
        args = get_version_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_version(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_version_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_version failed: unknown result")

    def start_heap_profile(self, session):
        """
        Parameters:
         - session

        """
        self.send_start_heap_profile(session)
        self.recv_start_heap_profile()

    def send_start_heap_profile(self, session):
        self._oprot.writeMessageBegin('start_heap_profile', TMessageType.CALL, self._seqid)
        args = start_heap_profile_args()
        args.session = session
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_start_heap_profile(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = start_heap_profile_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        return

    def stop_heap_profile(self, session):
        """
        Parameters:
         - session

        """
        self.send_stop_heap_profile(session)
        self.recv_stop_heap_profile()

    def send_stop_heap_profile(self, session):
        self._oprot.writeMessageBegin('stop_heap_profile', TMessageType.CALL, self._seqid)
        args = stop_heap_profile_args()
        args.session = session
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_stop_heap_profile(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = stop_heap_profile_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        return

    def get_heap_profile(self, session):
        """
        Parameters:
         - session

        """
        self.send_get_heap_profile(session)
        return self.recv_get_heap_profile()

    def send_get_heap_profile(self, session):
        self._oprot.writeMessageBegin('get_heap_profile', TMessageType.CALL, self._seqid)
        args = get_heap_profile_args()
        args.session = session
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_heap_profile(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_heap_profile_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_heap_profile failed: unknown result")

    def get_memory(self, session, memory_level):
        """
        Parameters:
         - session
         - memory_level

        """
        self.send_get_memory(session, memory_level)
        return self.recv_get_memory()

    def send_get_memory(self, session, memory_level):
        self._oprot.writeMessageBegin('get_memory', TMessageType.CALL, self._seqid)
        args = get_memory_args()
        args.session = session
        args.memory_level = memory_level
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_memory(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_memory_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_memory failed: unknown result")

    def clear_cpu_memory(self, session):
        """
        Parameters:
         - session

        """
        self.send_clear_cpu_memory(session)
        self.recv_clear_cpu_memory()

    def send_clear_cpu_memory(self, session):
        self._oprot.writeMessageBegin('clear_cpu_memory', TMessageType.CALL, self._seqid)
        args = clear_cpu_memory_args()
        args.session = session
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_clear_cpu_memory(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = clear_cpu_memory_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        return

    def clear_gpu_memory(self, session):
        """
        Parameters:
         - session

        """
        self.send_clear_gpu_memory(session)
        self.recv_clear_gpu_memory()

    def send_clear_gpu_memory(self, session):
        self._oprot.writeMessageBegin('clear_gpu_memory', TMessageType.CALL, self._seqid)
        args = clear_gpu_memory_args()
        args.session = session
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_clear_gpu_memory(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = clear_gpu_memory_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        return

    def set_cur_session(self, parent_session, leaf_session, start_time_str, label, for_running_query_kernel):
        """
        Parameters:
         - parent_session
         - leaf_session
         - start_time_str
         - label
         - for_running_query_kernel

        """
        self.send_set_cur_session(parent_session, leaf_session, start_time_str, label, for_running_query_kernel)
        self.recv_set_cur_session()

    def send_set_cur_session(self, parent_session, leaf_session, start_time_str, label, for_running_query_kernel):
        self._oprot.writeMessageBegin('set_cur_session', TMessageType.CALL, self._seqid)
        args = set_cur_session_args()
        args.parent_session = parent_session
        args.leaf_session = leaf_session
        args.start_time_str = start_time_str
        args.label = label
        args.for_running_query_kernel = for_running_query_kernel
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_set_cur_session(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = set_cur_session_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        return

    def invalidate_cur_session(self, parent_session, leaf_session, start_time_str, label, for_running_query_kernel):
        """
        Parameters:
         - parent_session
         - leaf_session
         - start_time_str
         - label
         - for_running_query_kernel

        """
        self.send_invalidate_cur_session(parent_session, leaf_session, start_time_str, label, for_running_query_kernel)
        self.recv_invalidate_cur_session()

    def send_invalidate_cur_session(self, parent_session, leaf_session, start_time_str, label, for_running_query_kernel):
        self._oprot.writeMessageBegin('invalidate_cur_session', TMessageType.CALL, self._seqid)
        args = invalidate_cur_session_args()
        args.parent_session = parent_session
        args.leaf_session = leaf_session
        args.start_time_str = start_time_str
        args.label = label
        args.for_running_query_kernel = for_running_query_kernel
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_invalidate_cur_session(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = invalidate_cur_session_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        return

    def set_table_epoch(self, session, db_id, table_id, new_epoch):
        """
        Parameters:
         - session
         - db_id
         - table_id
         - new_epoch

        """
        self.send_set_table_epoch(session, db_id, table_id, new_epoch)
        self.recv_set_table_epoch()

    def send_set_table_epoch(self, session, db_id, table_id, new_epoch):
        self._oprot.writeMessageBegin('set_table_epoch', TMessageType.CALL, self._seqid)
        args = set_table_epoch_args()
        args.session = session
        args.db_id = db_id
        args.table_id = table_id
        args.new_epoch = new_epoch
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_set_table_epoch(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = set_table_epoch_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        return

    def set_table_epoch_by_name(self, session, table_name, new_epoch):
        """
        Parameters:
         - session
         - table_name
         - new_epoch

        """
        self.send_set_table_epoch_by_name(session, table_name, new_epoch)
        self.recv_set_table_epoch_by_name()

    def send_set_table_epoch_by_name(self, session, table_name, new_epoch):
        self._oprot.writeMessageBegin('set_table_epoch_by_name', TMessageType.CALL, self._seqid)
        args = set_table_epoch_by_name_args()
        args.session = session
        args.table_name = table_name
        args.new_epoch = new_epoch
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_set_table_epoch_by_name(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = set_table_epoch_by_name_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        return

    def get_table_epoch(self, session, db_id, table_id):
        """
        Parameters:
         - session
         - db_id
         - table_id

        """
        self.send_get_table_epoch(session, db_id, table_id)
        return self.recv_get_table_epoch()

    def send_get_table_epoch(self, session, db_id, table_id):
        self._oprot.writeMessageBegin('get_table_epoch', TMessageType.CALL, self._seqid)
        args = get_table_epoch_args()
        args.session = session
        args.db_id = db_id
        args.table_id = table_id
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_table_epoch(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_table_epoch_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_table_epoch failed: unknown result")

    def get_table_epoch_by_name(self, session, table_name):
        """
        Parameters:
         - session
         - table_name

        """
        self.send_get_table_epoch_by_name(session, table_name)
        return self.recv_get_table_epoch_by_name()

    def send_get_table_epoch_by_name(self, session, table_name):
        self._oprot.writeMessageBegin('get_table_epoch_by_name', TMessageType.CALL, self._seqid)
        args = get_table_epoch_by_name_args()
        args.session = session
        args.table_name = table_name
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_table_epoch_by_name(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_table_epoch_by_name_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_table_epoch_by_name failed: unknown result")

    def get_table_epochs(self, session, db_id, table_id):
        """
        Parameters:
         - session
         - db_id
         - table_id

        """
        self.send_get_table_epochs(session, db_id, table_id)
        return self.recv_get_table_epochs()

    def send_get_table_epochs(self, session, db_id, table_id):
        self._oprot.writeMessageBegin('get_table_epochs', TMessageType.CALL, self._seqid)
        args = get_table_epochs_args()
        args.session = session
        args.db_id = db_id
        args.table_id = table_id
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_table_epochs(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_table_epochs_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_table_epochs failed: unknown result")

    def set_table_epochs(self, session, db_id, table_epochs):
        """
        Parameters:
         - session
         - db_id
         - table_epochs

        """
        self.send_set_table_epochs(session, db_id, table_epochs)
        self.recv_set_table_epochs()

    def send_set_table_epochs(self, session, db_id, table_epochs):
        self._oprot.writeMessageBegin('set_table_epochs', TMessageType.CALL, self._seqid)
        args = set_table_epochs_args()
        args.session = session
        args.db_id = db_id
        args.table_epochs = table_epochs
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_set_table_epochs(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = set_table_epochs_result()
        result.read(iprot)
        iprot.readMessageEnd()
        return

    def get_session_info(self, session):
        """
        Parameters:
         - session

        """
        self.send_get_session_info(session)
        return self.recv_get_session_info()

    def send_get_session_info(self, session):
        self._oprot.writeMessageBegin('get_session_info', TMessageType.CALL, self._seqid)
        args = get_session_info_args()
        args.session = session
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_session_info(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_session_info_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_session_info failed: unknown result")

    def get_queries_info(self, session):
        """
        Parameters:
         - session

        """
        self.send_get_queries_info(session)
        return self.recv_get_queries_info()

    def send_get_queries_info(self, session):
        self._oprot.writeMessageBegin('get_queries_info', TMessageType.CALL, self._seqid)
        args = get_queries_info_args()
        args.session = session
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_queries_info(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_queries_info_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_queries_info failed: unknown result")

    def set_leaf_info(self, session, leaf_info):
        """
        Parameters:
         - session
         - leaf_info

        """
        self.send_set_leaf_info(session, leaf_info)
        self.recv_set_leaf_info()

    def send_set_leaf_info(self, session, leaf_info):
        self._oprot.writeMessageBegin('set_leaf_info', TMessageType.CALL, self._seqid)
        args = set_leaf_info_args()
        args.session = session
        args.leaf_info = leaf_info
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_set_leaf_info(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = set_leaf_info_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        return

    def sql_execute(self, session, query, column_format, nonce, first_n, at_most_n):
        """
        Parameters:
         - session
         - query
         - column_format
         - nonce
         - first_n
         - at_most_n

        """
        self.send_sql_execute(session, query, column_format, nonce, first_n, at_most_n)
        return self.recv_sql_execute()

    def send_sql_execute(self, session, query, column_format, nonce, first_n, at_most_n):
        self._oprot.writeMessageBegin('sql_execute', TMessageType.CALL, self._seqid)
        args = sql_execute_args()
        args.session = session
        args.query = query
        args.column_format = column_format
        args.nonce = nonce
        args.first_n = first_n
        args.at_most_n = at_most_n
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_sql_execute(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = sql_execute_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TApplicationException(TApplicationException.MISSING_RESULT, "sql_execute failed: unknown result")

    def sql_execute_df(self, session, query, device_type, device_id, first_n, transport_method):
        """
        Parameters:
         - session
         - query
         - device_type
         - device_id
         - first_n
         - transport_method

        """
        self.send_sql_execute_df(session, query, device_type, device_id, first_n, transport_method)
        return self.recv_sql_execute_df()

    def send_sql_execute_df(self, session, query, device_type, device_id, first_n, transport_method):
        self._oprot.writeMessageBegin('sql_execute_df', TMessageType.CALL, self._seqid)
        args = sql_execute_df_args()
        args.session = session
        args.query = query
        args.device_type = device_type
        args.device_id = device_id
        args.first_n = first_n
        args.transport_method = transport_method
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_sql_execute_df(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = sql_execute_df_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TApplicationException(TApplicationException.MISSING_RESULT, "sql_execute_df failed: unknown result")

    def sql_execute_gdf(self, session, query, device_id, first_n):
        """
        Parameters:
         - session
         - query
         - device_id
         - first_n

        """
        self.send_sql_execute_gdf(session, query, device_id, first_n)
        return self.recv_sql_execute_gdf()

    def send_sql_execute_gdf(self, session, query, device_id, first_n):
        self._oprot.writeMessageBegin('sql_execute_gdf', TMessageType.CALL, self._seqid)
        args = sql_execute_gdf_args()
        args.session = session
        args.query = query
        args.device_id = device_id
        args.first_n = first_n
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_sql_execute_gdf(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = sql_execute_gdf_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TApplicationException(TApplicationException.MISSING_RESULT, "sql_execute_gdf failed: unknown result")

    def deallocate_df(self, session, df, device_type, device_id):
        """
        Parameters:
         - session
         - df
         - device_type
         - device_id

        """
        self.send_deallocate_df(session, df, device_type, device_id)
        self.recv_deallocate_df()

    def send_deallocate_df(self, session, df, device_type, device_id):
        self._oprot.writeMessageBegin('deallocate_df', TMessageType.CALL, self._seqid)
        args = deallocate_df_args()
        args.session = session
        args.df = df
        args.device_type = device_type
        args.device_id = device_id
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_deallocate_df(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = deallocate_df_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        return

    def interrupt(self, query_session, interrupt_session):
        """
        Parameters:
         - query_session
         - interrupt_session

        """
        self.send_interrupt(query_session, interrupt_session)
        self.recv_interrupt()

    def send_interrupt(self, query_session, interrupt_session):
        self._oprot.writeMessageBegin('interrupt', TMessageType.CALL, self._seqid)
        args = interrupt_args()
        args.query_session = query_session
        args.interrupt_session = interrupt_session
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_interrupt(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = interrupt_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        return

    def sql_validate(self, session, query):
        """
        Parameters:
         - session
         - query

        """
        self.send_sql_validate(session, query)
        return self.recv_sql_validate()

    def send_sql_validate(self, session, query):
        self._oprot.writeMessageBegin('sql_validate', TMessageType.CALL, self._seqid)
        args = sql_validate_args()
        args.session = session
        args.query = query
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_sql_validate(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = sql_validate_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TApplicationException(TApplicationException.MISSING_RESULT, "sql_validate failed: unknown result")

    def get_completion_hints(self, session, sql, cursor):
        """
        Parameters:
         - session
         - sql
         - cursor

        """
        self.send_get_completion_hints(session, sql, cursor)
        return self.recv_get_completion_hints()

    def send_get_completion_hints(self, session, sql, cursor):
        self._oprot.writeMessageBegin('get_completion_hints', TMessageType.CALL, self._seqid)
        args = get_completion_hints_args()
        args.session = session
        args.sql = sql
        args.cursor = cursor
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_completion_hints(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_completion_hints_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_completion_hints failed: unknown result")

    def set_execution_mode(self, session, mode):
        """
        Parameters:
         - session
         - mode

        """
        self.send_set_execution_mode(session, mode)
        self.recv_set_execution_mode()

    def send_set_execution_mode(self, session, mode):
        self._oprot.writeMessageBegin('set_execution_mode', TMessageType.CALL, self._seqid)
        args = set_execution_mode_args()
        args.session = session
        args.mode = mode
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_set_execution_mode(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = set_execution_mode_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        return

    def render_vega(self, session, widget_id, vega_json, compression_level, nonce):
        """
        Parameters:
         - session
         - widget_id
         - vega_json
         - compression_level
         - nonce

        """
        self.send_render_vega(session, widget_id, vega_json, compression_level, nonce)
        return self.recv_render_vega()

    def send_render_vega(self, session, widget_id, vega_json, compression_level, nonce):
        self._oprot.writeMessageBegin('render_vega', TMessageType.CALL, self._seqid)
        args = render_vega_args()
        args.session = session
        args.widget_id = widget_id
        args.vega_json = vega_json
        args.compression_level = compression_level
        args.nonce = nonce
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_render_vega(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = render_vega_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TApplicationException(TApplicationException.MISSING_RESULT, "render_vega failed: unknown result")

    def get_result_row_for_pixel(self, session, widget_id, pixel, table_col_names, column_format, pixelRadius, nonce):
        """
        Parameters:
         - session
         - widget_id
         - pixel
         - table_col_names
         - column_format
         - pixelRadius
         - nonce

        """
        self.send_get_result_row_for_pixel(session, widget_id, pixel, table_col_names, column_format, pixelRadius, nonce)
        return self.recv_get_result_row_for_pixel()

    def send_get_result_row_for_pixel(self, session, widget_id, pixel, table_col_names, column_format, pixelRadius, nonce):
        self._oprot.writeMessageBegin('get_result_row_for_pixel', TMessageType.CALL, self._seqid)
        args = get_result_row_for_pixel_args()
        args.session = session
        args.widget_id = widget_id
        args.pixel = pixel
        args.table_col_names = table_col_names
        args.column_format = column_format
        args.pixelRadius = pixelRadius
        args.nonce = nonce
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_result_row_for_pixel(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_result_row_for_pixel_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_result_row_for_pixel failed: unknown result")

    def create_custom_expression(self, session, custom_expression):
        """
        Parameters:
         - session
         - custom_expression

        """
        self.send_create_custom_expression(session, custom_expression)
        return self.recv_create_custom_expression()

    def send_create_custom_expression(self, session, custom_expression):
        self._oprot.writeMessageBegin('create_custom_expression', TMessageType.CALL, self._seqid)
        args = create_custom_expression_args()
        args.session = session
        args.custom_expression = custom_expression
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_create_custom_expression(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = create_custom_expression_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TApplicationException(TApplicationException.MISSING_RESULT, "create_custom_expression failed: unknown result")

    def get_custom_expressions(self, session):
        """
        Parameters:
         - session

        """
        self.send_get_custom_expressions(session)
        return self.recv_get_custom_expressions()

    def send_get_custom_expressions(self, session):
        self._oprot.writeMessageBegin('get_custom_expressions', TMessageType.CALL, self._seqid)
        args = get_custom_expressions_args()
        args.session = session
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_custom_expressions(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_custom_expressions_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_custom_expressions failed: unknown result")

    def update_custom_expression(self, session, id, expression_json):
        """
        Parameters:
         - session
         - id
         - expression_json

        """
        self.send_update_custom_expression(session, id, expression_json)
        self.recv_update_custom_expression()

    def send_update_custom_expression(self, session, id, expression_json):
        self._oprot.writeMessageBegin('update_custom_expression', TMessageType.CALL, self._seqid)
        args = update_custom_expression_args()
        args.session = session
        args.id = id
        args.expression_json = expression_json
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_update_custom_expression(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = update_custom_expression_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        return

    def delete_custom_expressions(self, session, custom_expression_ids, do_soft_delete):
        """
        Parameters:
         - session
         - custom_expression_ids
         - do_soft_delete

        """
        self.send_delete_custom_expressions(session, custom_expression_ids, do_soft_delete)
        self.recv_delete_custom_expressions()

    def send_delete_custom_expressions(self, session, custom_expression_ids, do_soft_delete):
        self._oprot.writeMessageBegin('delete_custom_expressions', TMessageType.CALL, self._seqid)
        args = delete_custom_expressions_args()
        args.session = session
        args.custom_expression_ids = custom_expression_ids
        args.do_soft_delete = do_soft_delete
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_delete_custom_expressions(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = delete_custom_expressions_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        return

    def get_dashboard(self, session, dashboard_id):
        """
        Parameters:
         - session
         - dashboard_id

        """
        self.send_get_dashboard(session, dashboard_id)
        return self.recv_get_dashboard()

    def send_get_dashboard(self, session, dashboard_id):
        self._oprot.writeMessageBegin('get_dashboard', TMessageType.CALL, self._seqid)
        args = get_dashboard_args()
        args.session = session
        args.dashboard_id = dashboard_id
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_dashboard(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_dashboard_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_dashboard failed: unknown result")

    def get_dashboards(self, session):
        """
        Parameters:
         - session

        """
        self.send_get_dashboards(session)
        return self.recv_get_dashboards()

    def send_get_dashboards(self, session):
        self._oprot.writeMessageBegin('get_dashboards', TMessageType.CALL, self._seqid)
        args = get_dashboards_args()
        args.session = session
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_dashboards(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_dashboards_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_dashboards failed: unknown result")

    def create_dashboard(self, session, dashboard_name, dashboard_state, image_hash, dashboard_metadata):
        """
        Parameters:
         - session
         - dashboard_name
         - dashboard_state
         - image_hash
         - dashboard_metadata

        """
        self.send_create_dashboard(session, dashboard_name, dashboard_state, image_hash, dashboard_metadata)
        return self.recv_create_dashboard()

    def send_create_dashboard(self, session, dashboard_name, dashboard_state, image_hash, dashboard_metadata):
        self._oprot.writeMessageBegin('create_dashboard', TMessageType.CALL, self._seqid)
        args = create_dashboard_args()
        args.session = session
        args.dashboard_name = dashboard_name
        args.dashboard_state = dashboard_state
        args.image_hash = image_hash
        args.dashboard_metadata = dashboard_metadata
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_create_dashboard(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = create_dashboard_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TApplicationException(TApplicationException.MISSING_RESULT, "create_dashboard failed: unknown result")

    def replace_dashboard(self, session, dashboard_id, dashboard_name, dashboard_owner, dashboard_state, image_hash, dashboard_metadata):
        """
        Parameters:
         - session
         - dashboard_id
         - dashboard_name
         - dashboard_owner
         - dashboard_state
         - image_hash
         - dashboard_metadata

        """
        self.send_replace_dashboard(session, dashboard_id, dashboard_name, dashboard_owner, dashboard_state, image_hash, dashboard_metadata)
        self.recv_replace_dashboard()

    def send_replace_dashboard(self, session, dashboard_id, dashboard_name, dashboard_owner, dashboard_state, image_hash, dashboard_metadata):
        self._oprot.writeMessageBegin('replace_dashboard', TMessageType.CALL, self._seqid)
        args = replace_dashboard_args()
        args.session = session
        args.dashboard_id = dashboard_id
        args.dashboard_name = dashboard_name
        args.dashboard_owner = dashboard_owner
        args.dashboard_state = dashboard_state
        args.image_hash = image_hash
        args.dashboard_metadata = dashboard_metadata
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_replace_dashboard(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = replace_dashboard_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        return

    def delete_dashboard(self, session, dashboard_id):
        """
        Parameters:
         - session
         - dashboard_id

        """
        self.send_delete_dashboard(session, dashboard_id)
        self.recv_delete_dashboard()

    def send_delete_dashboard(self, session, dashboard_id):
        self._oprot.writeMessageBegin('delete_dashboard', TMessageType.CALL, self._seqid)
        args = delete_dashboard_args()
        args.session = session
        args.dashboard_id = dashboard_id
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_delete_dashboard(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = delete_dashboard_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        return

    def share_dashboards(self, session, dashboard_ids, groups, permissions):
        """
        Parameters:
         - session
         - dashboard_ids
         - groups
         - permissions

        """
        self.send_share_dashboards(session, dashboard_ids, groups, permissions)
        self.recv_share_dashboards()

    def send_share_dashboards(self, session, dashboard_ids, groups, permissions):
        self._oprot.writeMessageBegin('share_dashboards', TMessageType.CALL, self._seqid)
        args = share_dashboards_args()
        args.session = session
        args.dashboard_ids = dashboard_ids
        args.groups = groups
        args.permissions = permissions
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_share_dashboards(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = share_dashboards_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        return

    def delete_dashboards(self, session, dashboard_ids):
        """
        Parameters:
         - session
         - dashboard_ids

        """
        self.send_delete_dashboards(session, dashboard_ids)
        self.recv_delete_dashboards()

    def send_delete_dashboards(self, session, dashboard_ids):
        self._oprot.writeMessageBegin('delete_dashboards', TMessageType.CALL, self._seqid)
        args = delete_dashboards_args()
        args.session = session
        args.dashboard_ids = dashboard_ids
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_delete_dashboards(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = delete_dashboards_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        return

    def share_dashboard(self, session, dashboard_id, groups, objects, permissions, grant_role):
        """
        Parameters:
         - session
         - dashboard_id
         - groups
         - objects
         - permissions
         - grant_role

        """
        self.send_share_dashboard(session, dashboard_id, groups, objects, permissions, grant_role)
        self.recv_share_dashboard()

    def send_share_dashboard(self, session, dashboard_id, groups, objects, permissions, grant_role):
        self._oprot.writeMessageBegin('share_dashboard', TMessageType.CALL, self._seqid)
        args = share_dashboard_args()
        args.session = session
        args.dashboard_id = dashboard_id
        args.groups = groups
        args.objects = objects
        args.permissions = permissions
        args.grant_role = grant_role
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_share_dashboard(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = share_dashboard_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        return

    def unshare_dashboard(self, session, dashboard_id, groups, objects, permissions):
        """
        Parameters:
         - session
         - dashboard_id
         - groups
         - objects
         - permissions

        """
        self.send_unshare_dashboard(session, dashboard_id, groups, objects, permissions)
        self.recv_unshare_dashboard()

    def send_unshare_dashboard(self, session, dashboard_id, groups, objects, permissions):
        self._oprot.writeMessageBegin('unshare_dashboard', TMessageType.CALL, self._seqid)
        args = unshare_dashboard_args()
        args.session = session
        args.dashboard_id = dashboard_id
        args.groups = groups
        args.objects = objects
        args.permissions = permissions
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_unshare_dashboard(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = unshare_dashboard_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        return

    def unshare_dashboards(self, session, dashboard_ids, groups, permissions):
        """
        Parameters:
         - session
         - dashboard_ids
         - groups
         - permissions

        """
        self.send_unshare_dashboards(session, dashboard_ids, groups, permissions)
        self.recv_unshare_dashboards()

    def send_unshare_dashboards(self, session, dashboard_ids, groups, permissions):
        self._oprot.writeMessageBegin('unshare_dashboards', TMessageType.CALL, self._seqid)
        args = unshare_dashboards_args()
        args.session = session
        args.dashboard_ids = dashboard_ids
        args.groups = groups
        args.permissions = permissions
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_unshare_dashboards(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = unshare_dashboards_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        return

    def get_dashboard_grantees(self, session, dashboard_id):
        """
        Parameters:
         - session
         - dashboard_id

        """
        self.send_get_dashboard_grantees(session, dashboard_id)
        return self.recv_get_dashboard_grantees()

    def send_get_dashboard_grantees(self, session, dashboard_id):
        self._oprot.writeMessageBegin('get_dashboard_grantees', TMessageType.CALL, self._seqid)
        args = get_dashboard_grantees_args()
        args.session = session
        args.dashboard_id = dashboard_id
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_dashboard_grantees(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_dashboard_grantees_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_dashboard_grantees failed: unknown result")

    def get_link_view(self, session, link):
        """
        Parameters:
         - session
         - link

        """
        self.send_get_link_view(session, link)
        return self.recv_get_link_view()

    def send_get_link_view(self, session, link):
        self._oprot.writeMessageBegin('get_link_view', TMessageType.CALL, self._seqid)
        args = get_link_view_args()
        args.session = session
        args.link = link
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_link_view(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_link_view_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_link_view failed: unknown result")

    def create_link(self, session, view_state, view_metadata):
        """
        Parameters:
         - session
         - view_state
         - view_metadata

        """
        self.send_create_link(session, view_state, view_metadata)
        return self.recv_create_link()

    def send_create_link(self, session, view_state, view_metadata):
        self._oprot.writeMessageBegin('create_link', TMessageType.CALL, self._seqid)
        args = create_link_args()
        args.session = session
        args.view_state = view_state
        args.view_metadata = view_metadata
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_create_link(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = create_link_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TApplicationException(TApplicationException.MISSING_RESULT, "create_link failed: unknown result")

    def load_table_binary(self, session, table_name, rows, column_names):
        """
        Parameters:
         - session
         - table_name
         - rows
         - column_names

        """
        self.send_load_table_binary(session, table_name, rows, column_names)
        self.recv_load_table_binary()

    def send_load_table_binary(self, session, table_name, rows, column_names):
        self._oprot.writeMessageBegin('load_table_binary', TMessageType.CALL, self._seqid)
        args = load_table_binary_args()
        args.session = session
        args.table_name = table_name
        args.rows = rows
        args.column_names = column_names
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_load_table_binary(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = load_table_binary_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        return

    def load_table_binary_columnar(self, session, table_name, cols, column_names):
        """
        Parameters:
         - session
         - table_name
         - cols
         - column_names

        """
        self.send_load_table_binary_columnar(session, table_name, cols, column_names)
        self.recv_load_table_binary_columnar()

    def send_load_table_binary_columnar(self, session, table_name, cols, column_names):
        self._oprot.writeMessageBegin('load_table_binary_columnar', TMessageType.CALL, self._seqid)
        args = load_table_binary_columnar_args()
        args.session = session
        args.table_name = table_name
        args.cols = cols
        args.column_names = column_names
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_load_table_binary_columnar(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = load_table_binary_columnar_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        return

    def load_table_binary_columnar_polys(self, session, table_name, cols, column_names, assign_render_groups):
        """
        Parameters:
         - session
         - table_name
         - cols
         - column_names
         - assign_render_groups

        """
        self.send_load_table_binary_columnar_polys(session, table_name, cols, column_names, assign_render_groups)
        self.recv_load_table_binary_columnar_polys()

    def send_load_table_binary_columnar_polys(self, session, table_name, cols, column_names, assign_render_groups):
        self._oprot.writeMessageBegin('load_table_binary_columnar_polys', TMessageType.CALL, self._seqid)
        args = load_table_binary_columnar_polys_args()
        args.session = session
        args.table_name = table_name
        args.cols = cols
        args.column_names = column_names
        args.assign_render_groups = assign_render_groups
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_load_table_binary_columnar_polys(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = load_table_binary_columnar_polys_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        return

    def load_table_binary_arrow(self, session, table_name, arrow_stream, use_column_names):
        """
        Parameters:
         - session
         - table_name
         - arrow_stream
         - use_column_names

        """
        self.send_load_table_binary_arrow(session, table_name, arrow_stream, use_column_names)
        self.recv_load_table_binary_arrow()

    def send_load_table_binary_arrow(self, session, table_name, arrow_stream, use_column_names):
        self._oprot.writeMessageBegin('load_table_binary_arrow', TMessageType.CALL, self._seqid)
        args = load_table_binary_arrow_args()
        args.session = session
        args.table_name = table_name
        args.arrow_stream = arrow_stream
        args.use_column_names = use_column_names
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_load_table_binary_arrow(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = load_table_binary_arrow_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        return

    def load_table(self, session, table_name, rows, column_names):
        """
        Parameters:
         - session
         - table_name
         - rows
         - column_names

        """
        self.send_load_table(session, table_name, rows, column_names)
        self.recv_load_table()

    def send_load_table(self, session, table_name, rows, column_names):
        self._oprot.writeMessageBegin('load_table', TMessageType.CALL, self._seqid)
        args = load_table_args()
        args.session = session
        args.table_name = table_name
        args.rows = rows
        args.column_names = column_names
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_load_table(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = load_table_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        return

    def detect_column_types(self, session, file_name, copy_params):
        """
        Parameters:
         - session
         - file_name
         - copy_params

        """
        self.send_detect_column_types(session, file_name, copy_params)
        return self.recv_detect_column_types()

    def send_detect_column_types(self, session, file_name, copy_params):
        self._oprot.writeMessageBegin('detect_column_types', TMessageType.CALL, self._seqid)
        args = detect_column_types_args()
        args.session = session
        args.file_name = file_name
        args.copy_params = copy_params
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_detect_column_types(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = detect_column_types_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TApplicationException(TApplicationException.MISSING_RESULT, "detect_column_types failed: unknown result")

    def create_table(self, session, table_name, row_desc, create_params):
        """
        Parameters:
         - session
         - table_name
         - row_desc
         - create_params

        """
        self.send_create_table(session, table_name, row_desc, create_params)
        self.recv_create_table()

    def send_create_table(self, session, table_name, row_desc, create_params):
        self._oprot.writeMessageBegin('create_table', TMessageType.CALL, self._seqid)
        args = create_table_args()
        args.session = session
        args.table_name = table_name
        args.row_desc = row_desc
        args.create_params = create_params
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_create_table(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = create_table_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        return

    def import_table(self, session, table_name, file_name, copy_params):
        """
        Parameters:
         - session
         - table_name
         - file_name
         - copy_params

        """
        self.send_import_table(session, table_name, file_name, copy_params)
        self.recv_import_table()

    def send_import_table(self, session, table_name, file_name, copy_params):
        self._oprot.writeMessageBegin('import_table', TMessageType.CALL, self._seqid)
        args = import_table_args()
        args.session = session
        args.table_name = table_name
        args.file_name = file_name
        args.copy_params = copy_params
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_import_table(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = import_table_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        return

    def import_geo_table(self, session, table_name, file_name, copy_params, row_desc, create_params):
        """
        Parameters:
         - session
         - table_name
         - file_name
         - copy_params
         - row_desc
         - create_params

        """
        self.send_import_geo_table(session, table_name, file_name, copy_params, row_desc, create_params)
        self.recv_import_geo_table()

    def send_import_geo_table(self, session, table_name, file_name, copy_params, row_desc, create_params):
        self._oprot.writeMessageBegin('import_geo_table', TMessageType.CALL, self._seqid)
        args = import_geo_table_args()
        args.session = session
        args.table_name = table_name
        args.file_name = file_name
        args.copy_params = copy_params
        args.row_desc = row_desc
        args.create_params = create_params
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_import_geo_table(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = import_geo_table_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        return

    def import_table_status(self, session, import_id):
        """
        Parameters:
         - session
         - import_id

        """
        self.send_import_table_status(session, import_id)
        return self.recv_import_table_status()

    def send_import_table_status(self, session, import_id):
        self._oprot.writeMessageBegin('import_table_status', TMessageType.CALL, self._seqid)
        args = import_table_status_args()
        args.session = session
        args.import_id = import_id
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_import_table_status(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = import_table_status_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TApplicationException(TApplicationException.MISSING_RESULT, "import_table_status failed: unknown result")

    def get_first_geo_file_in_archive(self, session, archive_path, copy_params):
        """
        Parameters:
         - session
         - archive_path
         - copy_params

        """
        self.send_get_first_geo_file_in_archive(session, archive_path, copy_params)
        return self.recv_get_first_geo_file_in_archive()

    def send_get_first_geo_file_in_archive(self, session, archive_path, copy_params):
        self._oprot.writeMessageBegin('get_first_geo_file_in_archive', TMessageType.CALL, self._seqid)
        args = get_first_geo_file_in_archive_args()
        args.session = session
        args.archive_path = archive_path
        args.copy_params = copy_params
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_first_geo_file_in_archive(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_first_geo_file_in_archive_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_first_geo_file_in_archive failed: unknown result")

    def get_all_files_in_archive(self, session, archive_path, copy_params):
        """
        Parameters:
         - session
         - archive_path
         - copy_params

        """
        self.send_get_all_files_in_archive(session, archive_path, copy_params)
        return self.recv_get_all_files_in_archive()

    def send_get_all_files_in_archive(self, session, archive_path, copy_params):
        self._oprot.writeMessageBegin('get_all_files_in_archive', TMessageType.CALL, self._seqid)
        args = get_all_files_in_archive_args()
        args.session = session
        args.archive_path = archive_path
        args.copy_params = copy_params
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_all_files_in_archive(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_all_files_in_archive_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_all_files_in_archive failed: unknown result")

    def get_layers_in_geo_file(self, session, file_name, copy_params):
        """
        Parameters:
         - session
         - file_name
         - copy_params

        """
        self.send_get_layers_in_geo_file(session, file_name, copy_params)
        return self.recv_get_layers_in_geo_file()

    def send_get_layers_in_geo_file(self, session, file_name, copy_params):
        self._oprot.writeMessageBegin('get_layers_in_geo_file', TMessageType.CALL, self._seqid)
        args = get_layers_in_geo_file_args()
        args.session = session
        args.file_name = file_name
        args.copy_params = copy_params
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_layers_in_geo_file(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_layers_in_geo_file_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_layers_in_geo_file failed: unknown result")

    def query_get_outer_fragment_count(self, session, query):
        """
        Parameters:
         - session
         - query

        """
        self.send_query_get_outer_fragment_count(session, query)
        return self.recv_query_get_outer_fragment_count()

    def send_query_get_outer_fragment_count(self, session, query):
        self._oprot.writeMessageBegin('query_get_outer_fragment_count', TMessageType.CALL, self._seqid)
        args = query_get_outer_fragment_count_args()
        args.session = session
        args.query = query
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_query_get_outer_fragment_count(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = query_get_outer_fragment_count_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TApplicationException(TApplicationException.MISSING_RESULT, "query_get_outer_fragment_count failed: unknown result")

    def check_table_consistency(self, session, table_id):
        """
        Parameters:
         - session
         - table_id

        """
        self.send_check_table_consistency(session, table_id)
        return self.recv_check_table_consistency()

    def send_check_table_consistency(self, session, table_id):
        self._oprot.writeMessageBegin('check_table_consistency', TMessageType.CALL, self._seqid)
        args = check_table_consistency_args()
        args.session = session
        args.table_id = table_id
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_check_table_consistency(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = check_table_consistency_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TApplicationException(TApplicationException.MISSING_RESULT, "check_table_consistency failed: unknown result")

    def start_query(self, leaf_session, parent_session, query_ra, start_time_str, just_explain, outer_fragment_indices):
        """
        Parameters:
         - leaf_session
         - parent_session
         - query_ra
         - start_time_str
         - just_explain
         - outer_fragment_indices

        """
        self.send_start_query(leaf_session, parent_session, query_ra, start_time_str, just_explain, outer_fragment_indices)
        return self.recv_start_query()

    def send_start_query(self, leaf_session, parent_session, query_ra, start_time_str, just_explain, outer_fragment_indices):
        self._oprot.writeMessageBegin('start_query', TMessageType.CALL, self._seqid)
        args = start_query_args()
        args.leaf_session = leaf_session
        args.parent_session = parent_session
        args.query_ra = query_ra
        args.start_time_str = start_time_str
        args.just_explain = just_explain
        args.outer_fragment_indices = outer_fragment_indices
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_start_query(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = start_query_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TApplicationException(TApplicationException.MISSING_RESULT, "start_query failed: unknown result")

    def execute_query_step(self, pending_query, subquery_id, start_time_str):
        """
        Parameters:
         - pending_query
         - subquery_id
         - start_time_str

        """
        self.send_execute_query_step(pending_query, subquery_id, start_time_str)
        return self.recv_execute_query_step()

    def send_execute_query_step(self, pending_query, subquery_id, start_time_str):
        self._oprot.writeMessageBegin('execute_query_step', TMessageType.CALL, self._seqid)
        args = execute_query_step_args()
        args.pending_query = pending_query
        args.subquery_id = subquery_id
        args.start_time_str = start_time_str
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_execute_query_step(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = execute_query_step_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TApplicationException(TApplicationException.MISSING_RESULT, "execute_query_step failed: unknown result")

    def broadcast_serialized_rows(self, serialized_rows, row_desc, query_id, subquery_id, is_final_subquery_result):
        """
        Parameters:
         - serialized_rows
         - row_desc
         - query_id
         - subquery_id
         - is_final_subquery_result

        """
        self.send_broadcast_serialized_rows(serialized_rows, row_desc, query_id, subquery_id, is_final_subquery_result)
        self.recv_broadcast_serialized_rows()

    def send_broadcast_serialized_rows(self, serialized_rows, row_desc, query_id, subquery_id, is_final_subquery_result):
        self._oprot.writeMessageBegin('broadcast_serialized_rows', TMessageType.CALL, self._seqid)
        args = broadcast_serialized_rows_args()
        args.serialized_rows = serialized_rows
        args.row_desc = row_desc
        args.query_id = query_id
        args.subquery_id = subquery_id
        args.is_final_subquery_result = is_final_subquery_result
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_broadcast_serialized_rows(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = broadcast_serialized_rows_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        return

    def start_render_query(self, session, widget_id, node_idx, vega_json):
        """
        Parameters:
         - session
         - widget_id
         - node_idx
         - vega_json

        """
        self.send_start_render_query(session, widget_id, node_idx, vega_json)
        return self.recv_start_render_query()

    def send_start_render_query(self, session, widget_id, node_idx, vega_json):
        self._oprot.writeMessageBegin('start_render_query', TMessageType.CALL, self._seqid)
        args = start_render_query_args()
        args.session = session
        args.widget_id = widget_id
        args.node_idx = node_idx
        args.vega_json = vega_json
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_start_render_query(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = start_render_query_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TApplicationException(TApplicationException.MISSING_RESULT, "start_render_query failed: unknown result")

    def execute_next_render_step(self, pending_render, merged_data):
        """
        Parameters:
         - pending_render
         - merged_data

        """
        self.send_execute_next_render_step(pending_render, merged_data)
        return self.recv_execute_next_render_step()

    def send_execute_next_render_step(self, pending_render, merged_data):
        self._oprot.writeMessageBegin('execute_next_render_step', TMessageType.CALL, self._seqid)
        args = execute_next_render_step_args()
        args.pending_render = pending_render
        args.merged_data = merged_data
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_execute_next_render_step(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = execute_next_render_step_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TApplicationException(TApplicationException.MISSING_RESULT, "execute_next_render_step failed: unknown result")

    def insert_data(self, session, insert_data):
        """
        Parameters:
         - session
         - insert_data

        """
        self.send_insert_data(session, insert_data)
        self.recv_insert_data()

    def send_insert_data(self, session, insert_data):
        self._oprot.writeMessageBegin('insert_data', TMessageType.CALL, self._seqid)
        args = insert_data_args()
        args.session = session
        args.insert_data = insert_data
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_insert_data(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = insert_data_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        return

    def insert_chunks(self, session, insert_chunks):
        """
        Parameters:
         - session
         - insert_chunks

        """
        self.send_insert_chunks(session, insert_chunks)
        self.recv_insert_chunks()

    def send_insert_chunks(self, session, insert_chunks):
        self._oprot.writeMessageBegin('insert_chunks', TMessageType.CALL, self._seqid)
        args = insert_chunks_args()
        args.session = session
        args.insert_chunks = insert_chunks
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_insert_chunks(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = insert_chunks_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        return

    def checkpoint(self, session, table_id):
        """
        Parameters:
         - session
         - table_id

        """
        self.send_checkpoint(session, table_id)
        self.recv_checkpoint()

    def send_checkpoint(self, session, table_id):
        self._oprot.writeMessageBegin('checkpoint', TMessageType.CALL, self._seqid)
        args = checkpoint_args()
        args.session = session
        args.table_id = table_id
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_checkpoint(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = checkpoint_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        return

    def get_roles(self, session):
        """
        Parameters:
         - session

        """
        self.send_get_roles(session)
        return self.recv_get_roles()

    def send_get_roles(self, session):
        self._oprot.writeMessageBegin('get_roles', TMessageType.CALL, self._seqid)
        args = get_roles_args()
        args.session = session
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_roles(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_roles_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_roles failed: unknown result")

    def get_db_objects_for_grantee(self, session, roleName):
        """
        Parameters:
         - session
         - roleName

        """
        self.send_get_db_objects_for_grantee(session, roleName)
        return self.recv_get_db_objects_for_grantee()

    def send_get_db_objects_for_grantee(self, session, roleName):
        self._oprot.writeMessageBegin('get_db_objects_for_grantee', TMessageType.CALL, self._seqid)
        args = get_db_objects_for_grantee_args()
        args.session = session
        args.roleName = roleName
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_db_objects_for_grantee(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_db_objects_for_grantee_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_db_objects_for_grantee failed: unknown result")

    def get_db_object_privs(self, session, objectName, type):
        """
        Parameters:
         - session
         - objectName
         - type

        """
        self.send_get_db_object_privs(session, objectName, type)
        return self.recv_get_db_object_privs()

    def send_get_db_object_privs(self, session, objectName, type):
        self._oprot.writeMessageBegin('get_db_object_privs', TMessageType.CALL, self._seqid)
        args = get_db_object_privs_args()
        args.session = session
        args.objectName = objectName
        args.type = type
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_db_object_privs(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_db_object_privs_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_db_object_privs failed: unknown result")

    def get_all_roles_for_user(self, session, userName):
        """
        Parameters:
         - session
         - userName

        """
        self.send_get_all_roles_for_user(session, userName)
        return self.recv_get_all_roles_for_user()

    def send_get_all_roles_for_user(self, session, userName):
        self._oprot.writeMessageBegin('get_all_roles_for_user', TMessageType.CALL, self._seqid)
        args = get_all_roles_for_user_args()
        args.session = session
        args.userName = userName
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_all_roles_for_user(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_all_roles_for_user_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_all_roles_for_user failed: unknown result")

    def get_all_effective_roles_for_user(self, session, userName):
        """
        Parameters:
         - session
         - userName

        """
        self.send_get_all_effective_roles_for_user(session, userName)
        return self.recv_get_all_effective_roles_for_user()

    def send_get_all_effective_roles_for_user(self, session, userName):
        self._oprot.writeMessageBegin('get_all_effective_roles_for_user', TMessageType.CALL, self._seqid)
        args = get_all_effective_roles_for_user_args()
        args.session = session
        args.userName = userName
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_all_effective_roles_for_user(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_all_effective_roles_for_user_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_all_effective_roles_for_user failed: unknown result")

    def has_role(self, session, granteeName, roleName):
        """
        Parameters:
         - session
         - granteeName
         - roleName

        """
        self.send_has_role(session, granteeName, roleName)
        return self.recv_has_role()

    def send_has_role(self, session, granteeName, roleName):
        self._oprot.writeMessageBegin('has_role', TMessageType.CALL, self._seqid)
        args = has_role_args()
        args.session = session
        args.granteeName = granteeName
        args.roleName = roleName
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_has_role(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = has_role_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TApplicationException(TApplicationException.MISSING_RESULT, "has_role failed: unknown result")

    def has_object_privilege(self, session, granteeName, ObjectName, objectType, permissions):
        """
        Parameters:
         - session
         - granteeName
         - ObjectName
         - objectType
         - permissions

        """
        self.send_has_object_privilege(session, granteeName, ObjectName, objectType, permissions)
        return self.recv_has_object_privilege()

    def send_has_object_privilege(self, session, granteeName, ObjectName, objectType, permissions):
        self._oprot.writeMessageBegin('has_object_privilege', TMessageType.CALL, self._seqid)
        args = has_object_privilege_args()
        args.session = session
        args.granteeName = granteeName
        args.ObjectName = ObjectName
        args.objectType = objectType
        args.permissions = permissions
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_has_object_privilege(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = has_object_privilege_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TApplicationException(TApplicationException.MISSING_RESULT, "has_object_privilege failed: unknown result")

    def set_license_key(self, session, key, nonce):
        """
        Parameters:
         - session
         - key
         - nonce

        """
        self.send_set_license_key(session, key, nonce)
        return self.recv_set_license_key()

    def send_set_license_key(self, session, key, nonce):
        self._oprot.writeMessageBegin('set_license_key', TMessageType.CALL, self._seqid)
        args = set_license_key_args()
        args.session = session
        args.key = key
        args.nonce = nonce
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_set_license_key(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = set_license_key_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TApplicationException(TApplicationException.MISSING_RESULT, "set_license_key failed: unknown result")

    def get_license_claims(self, session, nonce):
        """
        Parameters:
         - session
         - nonce

        """
        self.send_get_license_claims(session, nonce)
        return self.recv_get_license_claims()

    def send_get_license_claims(self, session, nonce):
        self._oprot.writeMessageBegin('get_license_claims', TMessageType.CALL, self._seqid)
        args = get_license_claims_args()
        args.session = session
        args.nonce = nonce
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_license_claims(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_license_claims_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_license_claims failed: unknown result")

    def get_device_parameters(self, session):
        """
        Parameters:
         - session

        """
        self.send_get_device_parameters(session)
        return self.recv_get_device_parameters()

    def send_get_device_parameters(self, session):
        self._oprot.writeMessageBegin('get_device_parameters', TMessageType.CALL, self._seqid)
        args = get_device_parameters_args()
        args.session = session
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_device_parameters(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_device_parameters_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_device_parameters failed: unknown result")

    def register_runtime_extension_functions(self, session, udfs, udtfs, device_ir_map):
        """
        Parameters:
         - session
         - udfs
         - udtfs
         - device_ir_map

        """
        self.send_register_runtime_extension_functions(session, udfs, udtfs, device_ir_map)
        self.recv_register_runtime_extension_functions()

    def send_register_runtime_extension_functions(self, session, udfs, udtfs, device_ir_map):
        self._oprot.writeMessageBegin('register_runtime_extension_functions', TMessageType.CALL, self._seqid)
        args = register_runtime_extension_functions_args()
        args.session = session
        args.udfs = udfs
        args.udtfs = udtfs
        args.device_ir_map = device_ir_map
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_register_runtime_extension_functions(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = register_runtime_extension_functions_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        return

    def get_table_function_names(self, session):
        """
        Parameters:
         - session

        """
        self.send_get_table_function_names(session)
        return self.recv_get_table_function_names()

    def send_get_table_function_names(self, session):
        self._oprot.writeMessageBegin('get_table_function_names', TMessageType.CALL, self._seqid)
        args = get_table_function_names_args()
        args.session = session
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_table_function_names(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_table_function_names_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_table_function_names failed: unknown result")

    def get_runtime_table_function_names(self, session):
        """
        Parameters:
         - session

        """
        self.send_get_runtime_table_function_names(session)
        return self.recv_get_runtime_table_function_names()

    def send_get_runtime_table_function_names(self, session):
        self._oprot.writeMessageBegin('get_runtime_table_function_names', TMessageType.CALL, self._seqid)
        args = get_runtime_table_function_names_args()
        args.session = session
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_runtime_table_function_names(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_runtime_table_function_names_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_runtime_table_function_names failed: unknown result")

    def get_table_function_details(self, session, udtf_names):
        """
        Parameters:
         - session
         - udtf_names

        """
        self.send_get_table_function_details(session, udtf_names)
        return self.recv_get_table_function_details()

    def send_get_table_function_details(self, session, udtf_names):
        self._oprot.writeMessageBegin('get_table_function_details', TMessageType.CALL, self._seqid)
        args = get_table_function_details_args()
        args.session = session
        args.udtf_names = udtf_names
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_table_function_details(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_table_function_details_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_table_function_details failed: unknown result")


class Processor(Iface, TProcessor):
    def __init__(self, handler):
        self._handler = handler
        self._processMap = {}
        self._processMap["connect"] = Processor.process_connect
        self._processMap["krb5_connect"] = Processor.process_krb5_connect
        self._processMap["disconnect"] = Processor.process_disconnect
        self._processMap["switch_database"] = Processor.process_switch_database
        self._processMap["clone_session"] = Processor.process_clone_session
        self._processMap["get_server_status"] = Processor.process_get_server_status
        self._processMap["get_status"] = Processor.process_get_status
        self._processMap["get_hardware_info"] = Processor.process_get_hardware_info
        self._processMap["get_tables"] = Processor.process_get_tables
        self._processMap["get_tables_for_database"] = Processor.process_get_tables_for_database
        self._processMap["get_physical_tables"] = Processor.process_get_physical_tables
        self._processMap["get_views"] = Processor.process_get_views
        self._processMap["get_tables_meta"] = Processor.process_get_tables_meta
        self._processMap["get_table_details"] = Processor.process_get_table_details
        self._processMap["get_table_details_for_database"] = Processor.process_get_table_details_for_database
        self._processMap["get_internal_table_details"] = Processor.process_get_internal_table_details
        self._processMap["get_internal_table_details_for_database"] = Processor.process_get_internal_table_details_for_database
        self._processMap["get_users"] = Processor.process_get_users
        self._processMap["get_databases"] = Processor.process_get_databases
        self._processMap["get_version"] = Processor.process_get_version
        self._processMap["start_heap_profile"] = Processor.process_start_heap_profile
        self._processMap["stop_heap_profile"] = Processor.process_stop_heap_profile
        self._processMap["get_heap_profile"] = Processor.process_get_heap_profile
        self._processMap["get_memory"] = Processor.process_get_memory
        self._processMap["clear_cpu_memory"] = Processor.process_clear_cpu_memory
        self._processMap["clear_gpu_memory"] = Processor.process_clear_gpu_memory
        self._processMap["set_cur_session"] = Processor.process_set_cur_session
        self._processMap["invalidate_cur_session"] = Processor.process_invalidate_cur_session
        self._processMap["set_table_epoch"] = Processor.process_set_table_epoch
        self._processMap["set_table_epoch_by_name"] = Processor.process_set_table_epoch_by_name
        self._processMap["get_table_epoch"] = Processor.process_get_table_epoch
        self._processMap["get_table_epoch_by_name"] = Processor.process_get_table_epoch_by_name
        self._processMap["get_table_epochs"] = Processor.process_get_table_epochs
        self._processMap["set_table_epochs"] = Processor.process_set_table_epochs
        self._processMap["get_session_info"] = Processor.process_get_session_info
        self._processMap["get_queries_info"] = Processor.process_get_queries_info
        self._processMap["set_leaf_info"] = Processor.process_set_leaf_info
        self._processMap["sql_execute"] = Processor.process_sql_execute
        self._processMap["sql_execute_df"] = Processor.process_sql_execute_df
        self._processMap["sql_execute_gdf"] = Processor.process_sql_execute_gdf
        self._processMap["deallocate_df"] = Processor.process_deallocate_df
        self._processMap["interrupt"] = Processor.process_interrupt
        self._processMap["sql_validate"] = Processor.process_sql_validate
        self._processMap["get_completion_hints"] = Processor.process_get_completion_hints
        self._processMap["set_execution_mode"] = Processor.process_set_execution_mode
        self._processMap["render_vega"] = Processor.process_render_vega
        self._processMap["get_result_row_for_pixel"] = Processor.process_get_result_row_for_pixel
        self._processMap["create_custom_expression"] = Processor.process_create_custom_expression
        self._processMap["get_custom_expressions"] = Processor.process_get_custom_expressions
        self._processMap["update_custom_expression"] = Processor.process_update_custom_expression
        self._processMap["delete_custom_expressions"] = Processor.process_delete_custom_expressions
        self._processMap["get_dashboard"] = Processor.process_get_dashboard
        self._processMap["get_dashboards"] = Processor.process_get_dashboards
        self._processMap["create_dashboard"] = Processor.process_create_dashboard
        self._processMap["replace_dashboard"] = Processor.process_replace_dashboard
        self._processMap["delete_dashboard"] = Processor.process_delete_dashboard
        self._processMap["share_dashboards"] = Processor.process_share_dashboards
        self._processMap["delete_dashboards"] = Processor.process_delete_dashboards
        self._processMap["share_dashboard"] = Processor.process_share_dashboard
        self._processMap["unshare_dashboard"] = Processor.process_unshare_dashboard
        self._processMap["unshare_dashboards"] = Processor.process_unshare_dashboards
        self._processMap["get_dashboard_grantees"] = Processor.process_get_dashboard_grantees
        self._processMap["get_link_view"] = Processor.process_get_link_view
        self._processMap["create_link"] = Processor.process_create_link
        self._processMap["load_table_binary"] = Processor.process_load_table_binary
        self._processMap["load_table_binary_columnar"] = Processor.process_load_table_binary_columnar
        self._processMap["load_table_binary_columnar_polys"] = Processor.process_load_table_binary_columnar_polys
        self._processMap["load_table_binary_arrow"] = Processor.process_load_table_binary_arrow
        self._processMap["load_table"] = Processor.process_load_table
        self._processMap["detect_column_types"] = Processor.process_detect_column_types
        self._processMap["create_table"] = Processor.process_create_table
        self._processMap["import_table"] = Processor.process_import_table
        self._processMap["import_geo_table"] = Processor.process_import_geo_table
        self._processMap["import_table_status"] = Processor.process_import_table_status
        self._processMap["get_first_geo_file_in_archive"] = Processor.process_get_first_geo_file_in_archive
        self._processMap["get_all_files_in_archive"] = Processor.process_get_all_files_in_archive
        self._processMap["get_layers_in_geo_file"] = Processor.process_get_layers_in_geo_file
        self._processMap["query_get_outer_fragment_count"] = Processor.process_query_get_outer_fragment_count
        self._processMap["check_table_consistency"] = Processor.process_check_table_consistency
        self._processMap["start_query"] = Processor.process_start_query
        self._processMap["execute_query_step"] = Processor.process_execute_query_step
        self._processMap["broadcast_serialized_rows"] = Processor.process_broadcast_serialized_rows
        self._processMap["start_render_query"] = Processor.process_start_render_query
        self._processMap["execute_next_render_step"] = Processor.process_execute_next_render_step
        self._processMap["insert_data"] = Processor.process_insert_data
        self._processMap["insert_chunks"] = Processor.process_insert_chunks
        self._processMap["checkpoint"] = Processor.process_checkpoint
        self._processMap["get_roles"] = Processor.process_get_roles
        self._processMap["get_db_objects_for_grantee"] = Processor.process_get_db_objects_for_grantee
        self._processMap["get_db_object_privs"] = Processor.process_get_db_object_privs
        self._processMap["get_all_roles_for_user"] = Processor.process_get_all_roles_for_user
        self._processMap["get_all_effective_roles_for_user"] = Processor.process_get_all_effective_roles_for_user
        self._processMap["has_role"] = Processor.process_has_role
        self._processMap["has_object_privilege"] = Processor.process_has_object_privilege
        self._processMap["set_license_key"] = Processor.process_set_license_key
        self._processMap["get_license_claims"] = Processor.process_get_license_claims
        self._processMap["get_device_parameters"] = Processor.process_get_device_parameters
        self._processMap["register_runtime_extension_functions"] = Processor.process_register_runtime_extension_functions
        self._processMap["get_table_function_names"] = Processor.process_get_table_function_names
        self._processMap["get_runtime_table_function_names"] = Processor.process_get_runtime_table_function_names
        self._processMap["get_table_function_details"] = Processor.process_get_table_function_details
        self._on_message_begin = None

    def on_message_begin(self, func):
        self._on_message_begin = func

    def process(self, iprot, oprot):
        (name, type, seqid) = iprot.readMessageBegin()
        if self._on_message_begin:
            self._on_message_begin(name, type, seqid)
        if name not in self._processMap:
            iprot.skip(TType.STRUCT)
            iprot.readMessageEnd()
            x = TApplicationException(TApplicationException.UNKNOWN_METHOD, 'Unknown function %s' % (name))
            oprot.writeMessageBegin(name, TMessageType.EXCEPTION, seqid)
            x.write(oprot)
            oprot.writeMessageEnd()
            oprot.trans.flush()
            return
        else:
            self._processMap[name](self, seqid, iprot, oprot)
        return True

    def process_connect(self, seqid, iprot, oprot):
        args = connect_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = connect_result()
        try:
            result.success = self._handler.connect(args.user, args.passwd, args.dbname)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TDBException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("connect", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_krb5_connect(self, seqid, iprot, oprot):
        args = krb5_connect_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = krb5_connect_result()
        try:
            result.success = self._handler.krb5_connect(args.inputToken, args.dbname)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TDBException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("krb5_connect", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_disconnect(self, seqid, iprot, oprot):
        args = disconnect_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = disconnect_result()
        try:
            self._handler.disconnect(args.session)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TDBException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("disconnect", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_switch_database(self, seqid, iprot, oprot):
        args = switch_database_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = switch_database_result()
        try:
            self._handler.switch_database(args.session, args.dbname)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TDBException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("switch_database", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_clone_session(self, seqid, iprot, oprot):
        args = clone_session_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = clone_session_result()
        try:
            result.success = self._handler.clone_session(args.session)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TDBException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("clone_session", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_server_status(self, seqid, iprot, oprot):
        args = get_server_status_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_server_status_result()
        try:
            result.success = self._handler.get_server_status(args.session)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TDBException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_server_status", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_status(self, seqid, iprot, oprot):
        args = get_status_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_status_result()
        try:
            result.success = self._handler.get_status(args.session)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TDBException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_status", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_hardware_info(self, seqid, iprot, oprot):
        args = get_hardware_info_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_hardware_info_result()
        try:
            result.success = self._handler.get_hardware_info(args.session)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TDBException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_hardware_info", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_tables(self, seqid, iprot, oprot):
        args = get_tables_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_tables_result()
        try:
            result.success = self._handler.get_tables(args.session)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TDBException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_tables", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_tables_for_database(self, seqid, iprot, oprot):
        args = get_tables_for_database_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_tables_for_database_result()
        try:
            result.success = self._handler.get_tables_for_database(args.session, args.database_name)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TDBException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_tables_for_database", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_physical_tables(self, seqid, iprot, oprot):
        args = get_physical_tables_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_physical_tables_result()
        try:
            result.success = self._handler.get_physical_tables(args.session)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TDBException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_physical_tables", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_views(self, seqid, iprot, oprot):
        args = get_views_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_views_result()
        try:
            result.success = self._handler.get_views(args.session)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TDBException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_views", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_tables_meta(self, seqid, iprot, oprot):
        args = get_tables_meta_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_tables_meta_result()
        try:
            result.success = self._handler.get_tables_meta(args.session)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TDBException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_tables_meta", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_table_details(self, seqid, iprot, oprot):
        args = get_table_details_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_table_details_result()
        try:
            result.success = self._handler.get_table_details(args.session, args.table_name)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TDBException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_table_details", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_table_details_for_database(self, seqid, iprot, oprot):
        args = get_table_details_for_database_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_table_details_for_database_result()
        try:
            result.success = self._handler.get_table_details_for_database(args.session, args.table_name, args.database_name)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TDBException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_table_details_for_database", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_internal_table_details(self, seqid, iprot, oprot):
        args = get_internal_table_details_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_internal_table_details_result()
        try:
            result.success = self._handler.get_internal_table_details(args.session, args.table_name, args.include_system_columns)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TDBException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_internal_table_details", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_internal_table_details_for_database(self, seqid, iprot, oprot):
        args = get_internal_table_details_for_database_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_internal_table_details_for_database_result()
        try:
            result.success = self._handler.get_internal_table_details_for_database(args.session, args.table_name, args.database_name)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TDBException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_internal_table_details_for_database", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_users(self, seqid, iprot, oprot):
        args = get_users_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_users_result()
        try:
            result.success = self._handler.get_users(args.session)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TDBException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_users", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_databases(self, seqid, iprot, oprot):
        args = get_databases_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_databases_result()
        try:
            result.success = self._handler.get_databases(args.session)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TDBException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_databases", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_version(self, seqid, iprot, oprot):
        args = get_version_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_version_result()
        try:
            result.success = self._handler.get_version()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TDBException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_version", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_start_heap_profile(self, seqid, iprot, oprot):
        args = start_heap_profile_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = start_heap_profile_result()
        try:
            self._handler.start_heap_profile(args.session)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TDBException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("start_heap_profile", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_stop_heap_profile(self, seqid, iprot, oprot):
        args = stop_heap_profile_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = stop_heap_profile_result()
        try:
            self._handler.stop_heap_profile(args.session)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TDBException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("stop_heap_profile", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_heap_profile(self, seqid, iprot, oprot):
        args = get_heap_profile_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_heap_profile_result()
        try:
            result.success = self._handler.get_heap_profile(args.session)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TDBException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_heap_profile", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_memory(self, seqid, iprot, oprot):
        args = get_memory_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_memory_result()
        try:
            result.success = self._handler.get_memory(args.session, args.memory_level)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TDBException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_memory", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_clear_cpu_memory(self, seqid, iprot, oprot):
        args = clear_cpu_memory_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = clear_cpu_memory_result()
        try:
            self._handler.clear_cpu_memory(args.session)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TDBException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("clear_cpu_memory", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_clear_gpu_memory(self, seqid, iprot, oprot):
        args = clear_gpu_memory_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = clear_gpu_memory_result()
        try:
            self._handler.clear_gpu_memory(args.session)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TDBException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("clear_gpu_memory", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_set_cur_session(self, seqid, iprot, oprot):
        args = set_cur_session_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = set_cur_session_result()
        try:
            self._handler.set_cur_session(args.parent_session, args.leaf_session, args.start_time_str, args.label, args.for_running_query_kernel)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TDBException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("set_cur_session", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_invalidate_cur_session(self, seqid, iprot, oprot):
        args = invalidate_cur_session_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = invalidate_cur_session_result()
        try:
            self._handler.invalidate_cur_session(args.parent_session, args.leaf_session, args.start_time_str, args.label, args.for_running_query_kernel)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TDBException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("invalidate_cur_session", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_set_table_epoch(self, seqid, iprot, oprot):
        args = set_table_epoch_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = set_table_epoch_result()
        try:
            self._handler.set_table_epoch(args.session, args.db_id, args.table_id, args.new_epoch)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TDBException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("set_table_epoch", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_set_table_epoch_by_name(self, seqid, iprot, oprot):
        args = set_table_epoch_by_name_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = set_table_epoch_by_name_result()
        try:
            self._handler.set_table_epoch_by_name(args.session, args.table_name, args.new_epoch)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TDBException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("set_table_epoch_by_name", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_table_epoch(self, seqid, iprot, oprot):
        args = get_table_epoch_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_table_epoch_result()
        try:
            result.success = self._handler.get_table_epoch(args.session, args.db_id, args.table_id)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_table_epoch", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_table_epoch_by_name(self, seqid, iprot, oprot):
        args = get_table_epoch_by_name_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_table_epoch_by_name_result()
        try:
            result.success = self._handler.get_table_epoch_by_name(args.session, args.table_name)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_table_epoch_by_name", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_table_epochs(self, seqid, iprot, oprot):
        args = get_table_epochs_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_table_epochs_result()
        try:
            result.success = self._handler.get_table_epochs(args.session, args.db_id, args.table_id)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_table_epochs", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_set_table_epochs(self, seqid, iprot, oprot):
        args = set_table_epochs_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = set_table_epochs_result()
        try:
            self._handler.set_table_epochs(args.session, args.db_id, args.table_epochs)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("set_table_epochs", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_session_info(self, seqid, iprot, oprot):
        args = get_session_info_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_session_info_result()
        try:
            result.success = self._handler.get_session_info(args.session)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TDBException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_session_info", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_queries_info(self, seqid, iprot, oprot):
        args = get_queries_info_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_queries_info_result()
        try:
            result.success = self._handler.get_queries_info(args.session)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TDBException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_queries_info", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_set_leaf_info(self, seqid, iprot, oprot):
        args = set_leaf_info_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = set_leaf_info_result()
        try:
            self._handler.set_leaf_info(args.session, args.leaf_info)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TDBException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("set_leaf_info", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_sql_execute(self, seqid, iprot, oprot):
        args = sql_execute_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = sql_execute_result()
        try:
            result.success = self._handler.sql_execute(args.session, args.query, args.column_format, args.nonce, args.first_n, args.at_most_n)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TDBException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("sql_execute", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_sql_execute_df(self, seqid, iprot, oprot):
        args = sql_execute_df_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = sql_execute_df_result()
        try:
            result.success = self._handler.sql_execute_df(args.session, args.query, args.device_type, args.device_id, args.first_n, args.transport_method)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TDBException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("sql_execute_df", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_sql_execute_gdf(self, seqid, iprot, oprot):
        args = sql_execute_gdf_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = sql_execute_gdf_result()
        try:
            result.success = self._handler.sql_execute_gdf(args.session, args.query, args.device_id, args.first_n)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TDBException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("sql_execute_gdf", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_deallocate_df(self, seqid, iprot, oprot):
        args = deallocate_df_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = deallocate_df_result()
        try:
            self._handler.deallocate_df(args.session, args.df, args.device_type, args.device_id)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TDBException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("deallocate_df", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_interrupt(self, seqid, iprot, oprot):
        args = interrupt_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = interrupt_result()
        try:
            self._handler.interrupt(args.query_session, args.interrupt_session)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TDBException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("interrupt", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_sql_validate(self, seqid, iprot, oprot):
        args = sql_validate_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = sql_validate_result()
        try:
            result.success = self._handler.sql_validate(args.session, args.query)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TDBException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("sql_validate", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_completion_hints(self, seqid, iprot, oprot):
        args = get_completion_hints_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_completion_hints_result()
        try:
            result.success = self._handler.get_completion_hints(args.session, args.sql, args.cursor)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TDBException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_completion_hints", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_set_execution_mode(self, seqid, iprot, oprot):
        args = set_execution_mode_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = set_execution_mode_result()
        try:
            self._handler.set_execution_mode(args.session, args.mode)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TDBException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("set_execution_mode", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_render_vega(self, seqid, iprot, oprot):
        args = render_vega_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = render_vega_result()
        try:
            result.success = self._handler.render_vega(args.session, args.widget_id, args.vega_json, args.compression_level, args.nonce)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TDBException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("render_vega", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_result_row_for_pixel(self, seqid, iprot, oprot):
        args = get_result_row_for_pixel_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_result_row_for_pixel_result()
        try:
            result.success = self._handler.get_result_row_for_pixel(args.session, args.widget_id, args.pixel, args.table_col_names, args.column_format, args.pixelRadius, args.nonce)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TDBException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_result_row_for_pixel", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_create_custom_expression(self, seqid, iprot, oprot):
        args = create_custom_expression_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = create_custom_expression_result()
        try:
            result.success = self._handler.create_custom_expression(args.session, args.custom_expression)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TDBException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("create_custom_expression", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_custom_expressions(self, seqid, iprot, oprot):
        args = get_custom_expressions_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_custom_expressions_result()
        try:
            result.success = self._handler.get_custom_expressions(args.session)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TDBException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_custom_expressions", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_update_custom_expression(self, seqid, iprot, oprot):
        args = update_custom_expression_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = update_custom_expression_result()
        try:
            self._handler.update_custom_expression(args.session, args.id, args.expression_json)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TDBException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("update_custom_expression", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_delete_custom_expressions(self, seqid, iprot, oprot):
        args = delete_custom_expressions_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = delete_custom_expressions_result()
        try:
            self._handler.delete_custom_expressions(args.session, args.custom_expression_ids, args.do_soft_delete)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TDBException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("delete_custom_expressions", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_dashboard(self, seqid, iprot, oprot):
        args = get_dashboard_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_dashboard_result()
        try:
            result.success = self._handler.get_dashboard(args.session, args.dashboard_id)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TDBException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_dashboard", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_dashboards(self, seqid, iprot, oprot):
        args = get_dashboards_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_dashboards_result()
        try:
            result.success = self._handler.get_dashboards(args.session)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TDBException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_dashboards", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_create_dashboard(self, seqid, iprot, oprot):
        args = create_dashboard_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = create_dashboard_result()
        try:
            result.success = self._handler.create_dashboard(args.session, args.dashboard_name, args.dashboard_state, args.image_hash, args.dashboard_metadata)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TDBException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("create_dashboard", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_replace_dashboard(self, seqid, iprot, oprot):
        args = replace_dashboard_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = replace_dashboard_result()
        try:
            self._handler.replace_dashboard(args.session, args.dashboard_id, args.dashboard_name, args.dashboard_owner, args.dashboard_state, args.image_hash, args.dashboard_metadata)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TDBException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("replace_dashboard", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_delete_dashboard(self, seqid, iprot, oprot):
        args = delete_dashboard_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = delete_dashboard_result()
        try:
            self._handler.delete_dashboard(args.session, args.dashboard_id)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TDBException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("delete_dashboard", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_share_dashboards(self, seqid, iprot, oprot):
        args = share_dashboards_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = share_dashboards_result()
        try:
            self._handler.share_dashboards(args.session, args.dashboard_ids, args.groups, args.permissions)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TDBException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("share_dashboards", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_delete_dashboards(self, seqid, iprot, oprot):
        args = delete_dashboards_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = delete_dashboards_result()
        try:
            self._handler.delete_dashboards(args.session, args.dashboard_ids)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TDBException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("delete_dashboards", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_share_dashboard(self, seqid, iprot, oprot):
        args = share_dashboard_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = share_dashboard_result()
        try:
            self._handler.share_dashboard(args.session, args.dashboard_id, args.groups, args.objects, args.permissions, args.grant_role)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TDBException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("share_dashboard", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_unshare_dashboard(self, seqid, iprot, oprot):
        args = unshare_dashboard_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = unshare_dashboard_result()
        try:
            self._handler.unshare_dashboard(args.session, args.dashboard_id, args.groups, args.objects, args.permissions)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TDBException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("unshare_dashboard", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_unshare_dashboards(self, seqid, iprot, oprot):
        args = unshare_dashboards_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = unshare_dashboards_result()
        try:
            self._handler.unshare_dashboards(args.session, args.dashboard_ids, args.groups, args.permissions)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TDBException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("unshare_dashboards", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_dashboard_grantees(self, seqid, iprot, oprot):
        args = get_dashboard_grantees_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_dashboard_grantees_result()
        try:
            result.success = self._handler.get_dashboard_grantees(args.session, args.dashboard_id)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TDBException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_dashboard_grantees", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_link_view(self, seqid, iprot, oprot):
        args = get_link_view_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_link_view_result()
        try:
            result.success = self._handler.get_link_view(args.session, args.link)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TDBException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_link_view", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_create_link(self, seqid, iprot, oprot):
        args = create_link_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = create_link_result()
        try:
            result.success = self._handler.create_link(args.session, args.view_state, args.view_metadata)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TDBException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("create_link", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_load_table_binary(self, seqid, iprot, oprot):
        args = load_table_binary_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = load_table_binary_result()
        try:
            self._handler.load_table_binary(args.session, args.table_name, args.rows, args.column_names)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TDBException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("load_table_binary", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_load_table_binary_columnar(self, seqid, iprot, oprot):
        args = load_table_binary_columnar_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = load_table_binary_columnar_result()
        try:
            self._handler.load_table_binary_columnar(args.session, args.table_name, args.cols, args.column_names)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TDBException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("load_table_binary_columnar", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_load_table_binary_columnar_polys(self, seqid, iprot, oprot):
        args = load_table_binary_columnar_polys_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = load_table_binary_columnar_polys_result()
        try:
            self._handler.load_table_binary_columnar_polys(args.session, args.table_name, args.cols, args.column_names, args.assign_render_groups)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TDBException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("load_table_binary_columnar_polys", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_load_table_binary_arrow(self, seqid, iprot, oprot):
        args = load_table_binary_arrow_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = load_table_binary_arrow_result()
        try:
            self._handler.load_table_binary_arrow(args.session, args.table_name, args.arrow_stream, args.use_column_names)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TDBException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("load_table_binary_arrow", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_load_table(self, seqid, iprot, oprot):
        args = load_table_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = load_table_result()
        try:
            self._handler.load_table(args.session, args.table_name, args.rows, args.column_names)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TDBException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("load_table", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_detect_column_types(self, seqid, iprot, oprot):
        args = detect_column_types_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = detect_column_types_result()
        try:
            result.success = self._handler.detect_column_types(args.session, args.file_name, args.copy_params)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TDBException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("detect_column_types", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_create_table(self, seqid, iprot, oprot):
        args = create_table_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = create_table_result()
        try:
            self._handler.create_table(args.session, args.table_name, args.row_desc, args.create_params)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TDBException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("create_table", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_import_table(self, seqid, iprot, oprot):
        args = import_table_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = import_table_result()
        try:
            self._handler.import_table(args.session, args.table_name, args.file_name, args.copy_params)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TDBException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("import_table", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_import_geo_table(self, seqid, iprot, oprot):
        args = import_geo_table_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = import_geo_table_result()
        try:
            self._handler.import_geo_table(args.session, args.table_name, args.file_name, args.copy_params, args.row_desc, args.create_params)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TDBException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("import_geo_table", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_import_table_status(self, seqid, iprot, oprot):
        args = import_table_status_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = import_table_status_result()
        try:
            result.success = self._handler.import_table_status(args.session, args.import_id)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TDBException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("import_table_status", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_first_geo_file_in_archive(self, seqid, iprot, oprot):
        args = get_first_geo_file_in_archive_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_first_geo_file_in_archive_result()
        try:
            result.success = self._handler.get_first_geo_file_in_archive(args.session, args.archive_path, args.copy_params)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TDBException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_first_geo_file_in_archive", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_all_files_in_archive(self, seqid, iprot, oprot):
        args = get_all_files_in_archive_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_all_files_in_archive_result()
        try:
            result.success = self._handler.get_all_files_in_archive(args.session, args.archive_path, args.copy_params)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TDBException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_all_files_in_archive", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_layers_in_geo_file(self, seqid, iprot, oprot):
        args = get_layers_in_geo_file_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_layers_in_geo_file_result()
        try:
            result.success = self._handler.get_layers_in_geo_file(args.session, args.file_name, args.copy_params)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TDBException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_layers_in_geo_file", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_query_get_outer_fragment_count(self, seqid, iprot, oprot):
        args = query_get_outer_fragment_count_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = query_get_outer_fragment_count_result()
        try:
            result.success = self._handler.query_get_outer_fragment_count(args.session, args.query)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TDBException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("query_get_outer_fragment_count", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_check_table_consistency(self, seqid, iprot, oprot):
        args = check_table_consistency_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = check_table_consistency_result()
        try:
            result.success = self._handler.check_table_consistency(args.session, args.table_id)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TDBException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("check_table_consistency", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_start_query(self, seqid, iprot, oprot):
        args = start_query_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = start_query_result()
        try:
            result.success = self._handler.start_query(args.leaf_session, args.parent_session, args.query_ra, args.start_time_str, args.just_explain, args.outer_fragment_indices)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TDBException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("start_query", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_execute_query_step(self, seqid, iprot, oprot):
        args = execute_query_step_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = execute_query_step_result()
        try:
            result.success = self._handler.execute_query_step(args.pending_query, args.subquery_id, args.start_time_str)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TDBException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("execute_query_step", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_broadcast_serialized_rows(self, seqid, iprot, oprot):
        args = broadcast_serialized_rows_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = broadcast_serialized_rows_result()
        try:
            self._handler.broadcast_serialized_rows(args.serialized_rows, args.row_desc, args.query_id, args.subquery_id, args.is_final_subquery_result)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TDBException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("broadcast_serialized_rows", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_start_render_query(self, seqid, iprot, oprot):
        args = start_render_query_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = start_render_query_result()
        try:
            result.success = self._handler.start_render_query(args.session, args.widget_id, args.node_idx, args.vega_json)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TDBException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("start_render_query", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_execute_next_render_step(self, seqid, iprot, oprot):
        args = execute_next_render_step_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = execute_next_render_step_result()
        try:
            result.success = self._handler.execute_next_render_step(args.pending_render, args.merged_data)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TDBException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("execute_next_render_step", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_insert_data(self, seqid, iprot, oprot):
        args = insert_data_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = insert_data_result()
        try:
            self._handler.insert_data(args.session, args.insert_data)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TDBException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("insert_data", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_insert_chunks(self, seqid, iprot, oprot):
        args = insert_chunks_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = insert_chunks_result()
        try:
            self._handler.insert_chunks(args.session, args.insert_chunks)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TDBException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("insert_chunks", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_checkpoint(self, seqid, iprot, oprot):
        args = checkpoint_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = checkpoint_result()
        try:
            self._handler.checkpoint(args.session, args.table_id)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TDBException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("checkpoint", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_roles(self, seqid, iprot, oprot):
        args = get_roles_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_roles_result()
        try:
            result.success = self._handler.get_roles(args.session)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TDBException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_roles", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_db_objects_for_grantee(self, seqid, iprot, oprot):
        args = get_db_objects_for_grantee_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_db_objects_for_grantee_result()
        try:
            result.success = self._handler.get_db_objects_for_grantee(args.session, args.roleName)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TDBException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_db_objects_for_grantee", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_db_object_privs(self, seqid, iprot, oprot):
        args = get_db_object_privs_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_db_object_privs_result()
        try:
            result.success = self._handler.get_db_object_privs(args.session, args.objectName, args.type)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TDBException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_db_object_privs", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_all_roles_for_user(self, seqid, iprot, oprot):
        args = get_all_roles_for_user_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_all_roles_for_user_result()
        try:
            result.success = self._handler.get_all_roles_for_user(args.session, args.userName)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TDBException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_all_roles_for_user", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_all_effective_roles_for_user(self, seqid, iprot, oprot):
        args = get_all_effective_roles_for_user_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_all_effective_roles_for_user_result()
        try:
            result.success = self._handler.get_all_effective_roles_for_user(args.session, args.userName)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TDBException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_all_effective_roles_for_user", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_has_role(self, seqid, iprot, oprot):
        args = has_role_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = has_role_result()
        try:
            result.success = self._handler.has_role(args.session, args.granteeName, args.roleName)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TDBException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("has_role", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_has_object_privilege(self, seqid, iprot, oprot):
        args = has_object_privilege_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = has_object_privilege_result()
        try:
            result.success = self._handler.has_object_privilege(args.session, args.granteeName, args.ObjectName, args.objectType, args.permissions)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TDBException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("has_object_privilege", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_set_license_key(self, seqid, iprot, oprot):
        args = set_license_key_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = set_license_key_result()
        try:
            result.success = self._handler.set_license_key(args.session, args.key, args.nonce)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TDBException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("set_license_key", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_license_claims(self, seqid, iprot, oprot):
        args = get_license_claims_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_license_claims_result()
        try:
            result.success = self._handler.get_license_claims(args.session, args.nonce)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TDBException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_license_claims", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_device_parameters(self, seqid, iprot, oprot):
        args = get_device_parameters_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_device_parameters_result()
        try:
            result.success = self._handler.get_device_parameters(args.session)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TDBException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_device_parameters", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_register_runtime_extension_functions(self, seqid, iprot, oprot):
        args = register_runtime_extension_functions_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = register_runtime_extension_functions_result()
        try:
            self._handler.register_runtime_extension_functions(args.session, args.udfs, args.udtfs, args.device_ir_map)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TDBException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("register_runtime_extension_functions", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_table_function_names(self, seqid, iprot, oprot):
        args = get_table_function_names_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_table_function_names_result()
        try:
            result.success = self._handler.get_table_function_names(args.session)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TDBException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_table_function_names", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_runtime_table_function_names(self, seqid, iprot, oprot):
        args = get_runtime_table_function_names_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_runtime_table_function_names_result()
        try:
            result.success = self._handler.get_runtime_table_function_names(args.session)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TDBException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_runtime_table_function_names", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_table_function_details(self, seqid, iprot, oprot):
        args = get_table_function_details_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_table_function_details_result()
        try:
            result.success = self._handler.get_table_function_details(args.session, args.udtf_names)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TDBException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_table_function_details", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

# HELPER FUNCTIONS AND STRUCTURES


class connect_args(object):
    """
    Attributes:
     - user
     - passwd
     - dbname

    """


    def __init__(self, user=None, passwd=None, dbname=None,):
        self.user = user
        self.passwd = passwd
        self.dbname = dbname

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.user = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.passwd = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.dbname = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('connect_args')
        if self.user is not None:
            oprot.writeFieldBegin('user', TType.STRING, 1)
            oprot.writeString(self.user.encode('utf-8') if sys.version_info[0] == 2 else self.user)
            oprot.writeFieldEnd()
        if self.passwd is not None:
            oprot.writeFieldBegin('passwd', TType.STRING, 2)
            oprot.writeString(self.passwd.encode('utf-8') if sys.version_info[0] == 2 else self.passwd)
            oprot.writeFieldEnd()
        if self.dbname is not None:
            oprot.writeFieldBegin('dbname', TType.STRING, 3)
            oprot.writeString(self.dbname.encode('utf-8') if sys.version_info[0] == 2 else self.dbname)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(connect_args)
connect_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'user', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'passwd', 'UTF8', None, ),  # 2
    (3, TType.STRING, 'dbname', 'UTF8', None, ),  # 3
)


class connect_result(object):
    """
    Attributes:
     - success
     - e

    """


    def __init__(self, success=None, e=None,):
        self.success = success
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRING:
                    self.success = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TDBException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('connect_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRING, 0)
            oprot.writeString(self.success.encode('utf-8') if sys.version_info[0] == 2 else self.success)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(connect_result)
connect_result.thrift_spec = (
    (0, TType.STRING, 'success', 'UTF8', None, ),  # 0
    (1, TType.STRUCT, 'e', [TDBException, None], None, ),  # 1
)


class krb5_connect_args(object):
    """
    Attributes:
     - inputToken
     - dbname

    """


    def __init__(self, inputToken=None, dbname=None,):
        self.inputToken = inputToken
        self.dbname = dbname

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.inputToken = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.dbname = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('krb5_connect_args')
        if self.inputToken is not None:
            oprot.writeFieldBegin('inputToken', TType.STRING, 1)
            oprot.writeString(self.inputToken.encode('utf-8') if sys.version_info[0] == 2 else self.inputToken)
            oprot.writeFieldEnd()
        if self.dbname is not None:
            oprot.writeFieldBegin('dbname', TType.STRING, 2)
            oprot.writeString(self.dbname.encode('utf-8') if sys.version_info[0] == 2 else self.dbname)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(krb5_connect_args)
krb5_connect_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'inputToken', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'dbname', 'UTF8', None, ),  # 2
)


class krb5_connect_result(object):
    """
    Attributes:
     - success
     - e

    """


    def __init__(self, success=None, e=None,):
        self.success = success
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = TKrb5Session()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TDBException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('krb5_connect_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(krb5_connect_result)
krb5_connect_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [TKrb5Session, None], None, ),  # 0
    (1, TType.STRUCT, 'e', [TDBException, None], None, ),  # 1
)


class disconnect_args(object):
    """
    Attributes:
     - session

    """


    def __init__(self, session=None,):
        self.session = session

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.session = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('disconnect_args')
        if self.session is not None:
            oprot.writeFieldBegin('session', TType.STRING, 1)
            oprot.writeString(self.session.encode('utf-8') if sys.version_info[0] == 2 else self.session)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(disconnect_args)
disconnect_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'session', 'UTF8', None, ),  # 1
)


class disconnect_result(object):
    """
    Attributes:
     - e

    """


    def __init__(self, e=None,):
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TDBException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('disconnect_result')
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(disconnect_result)
disconnect_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'e', [TDBException, None], None, ),  # 1
)


class switch_database_args(object):
    """
    Attributes:
     - session
     - dbname

    """


    def __init__(self, session=None, dbname=None,):
        self.session = session
        self.dbname = dbname

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.session = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.dbname = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('switch_database_args')
        if self.session is not None:
            oprot.writeFieldBegin('session', TType.STRING, 1)
            oprot.writeString(self.session.encode('utf-8') if sys.version_info[0] == 2 else self.session)
            oprot.writeFieldEnd()
        if self.dbname is not None:
            oprot.writeFieldBegin('dbname', TType.STRING, 2)
            oprot.writeString(self.dbname.encode('utf-8') if sys.version_info[0] == 2 else self.dbname)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(switch_database_args)
switch_database_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'session', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'dbname', 'UTF8', None, ),  # 2
)


class switch_database_result(object):
    """
    Attributes:
     - e

    """


    def __init__(self, e=None,):
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TDBException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('switch_database_result')
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(switch_database_result)
switch_database_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'e', [TDBException, None], None, ),  # 1
)


class clone_session_args(object):
    """
    Attributes:
     - session

    """


    def __init__(self, session=None,):
        self.session = session

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.session = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('clone_session_args')
        if self.session is not None:
            oprot.writeFieldBegin('session', TType.STRING, 1)
            oprot.writeString(self.session.encode('utf-8') if sys.version_info[0] == 2 else self.session)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(clone_session_args)
clone_session_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'session', 'UTF8', None, ),  # 1
)


class clone_session_result(object):
    """
    Attributes:
     - success
     - e

    """


    def __init__(self, success=None, e=None,):
        self.success = success
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRING:
                    self.success = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TDBException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('clone_session_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRING, 0)
            oprot.writeString(self.success.encode('utf-8') if sys.version_info[0] == 2 else self.success)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(clone_session_result)
clone_session_result.thrift_spec = (
    (0, TType.STRING, 'success', 'UTF8', None, ),  # 0
    (1, TType.STRUCT, 'e', [TDBException, None], None, ),  # 1
)


class get_server_status_args(object):
    """
    Attributes:
     - session

    """


    def __init__(self, session=None,):
        self.session = session

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.session = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_server_status_args')
        if self.session is not None:
            oprot.writeFieldBegin('session', TType.STRING, 1)
            oprot.writeString(self.session.encode('utf-8') if sys.version_info[0] == 2 else self.session)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_server_status_args)
get_server_status_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'session', 'UTF8', None, ),  # 1
)


class get_server_status_result(object):
    """
    Attributes:
     - success
     - e

    """


    def __init__(self, success=None, e=None,):
        self.success = success
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = TServerStatus()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TDBException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_server_status_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_server_status_result)
get_server_status_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [TServerStatus, None], None, ),  # 0
    (1, TType.STRUCT, 'e', [TDBException, None], None, ),  # 1
)


class get_status_args(object):
    """
    Attributes:
     - session

    """


    def __init__(self, session=None,):
        self.session = session

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.session = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_status_args')
        if self.session is not None:
            oprot.writeFieldBegin('session', TType.STRING, 1)
            oprot.writeString(self.session.encode('utf-8') if sys.version_info[0] == 2 else self.session)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_status_args)
get_status_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'session', 'UTF8', None, ),  # 1
)


class get_status_result(object):
    """
    Attributes:
     - success
     - e

    """


    def __init__(self, success=None, e=None,):
        self.success = success
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype279, _size276) = iprot.readListBegin()
                    for _i280 in range(_size276):
                        _elem281 = TServerStatus()
                        _elem281.read(iprot)
                        self.success.append(_elem281)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TDBException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_status_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter282 in self.success:
                iter282.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_status_result)
get_status_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT, [TServerStatus, None], False), None, ),  # 0
    (1, TType.STRUCT, 'e', [TDBException, None], None, ),  # 1
)


class get_hardware_info_args(object):
    """
    Attributes:
     - session

    """


    def __init__(self, session=None,):
        self.session = session

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.session = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_hardware_info_args')
        if self.session is not None:
            oprot.writeFieldBegin('session', TType.STRING, 1)
            oprot.writeString(self.session.encode('utf-8') if sys.version_info[0] == 2 else self.session)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_hardware_info_args)
get_hardware_info_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'session', 'UTF8', None, ),  # 1
)


class get_hardware_info_result(object):
    """
    Attributes:
     - success
     - e

    """


    def __init__(self, success=None, e=None,):
        self.success = success
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = TClusterHardwareInfo()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TDBException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_hardware_info_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_hardware_info_result)
get_hardware_info_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [TClusterHardwareInfo, None], None, ),  # 0
    (1, TType.STRUCT, 'e', [TDBException, None], None, ),  # 1
)


class get_tables_args(object):
    """
    Attributes:
     - session

    """


    def __init__(self, session=None,):
        self.session = session

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.session = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_tables_args')
        if self.session is not None:
            oprot.writeFieldBegin('session', TType.STRING, 1)
            oprot.writeString(self.session.encode('utf-8') if sys.version_info[0] == 2 else self.session)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_tables_args)
get_tables_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'session', 'UTF8', None, ),  # 1
)


class get_tables_result(object):
    """
    Attributes:
     - success
     - e

    """


    def __init__(self, success=None, e=None,):
        self.success = success
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype286, _size283) = iprot.readListBegin()
                    for _i287 in range(_size283):
                        _elem288 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.success.append(_elem288)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TDBException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_tables_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRING, len(self.success))
            for iter289 in self.success:
                oprot.writeString(iter289.encode('utf-8') if sys.version_info[0] == 2 else iter289)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_tables_result)
get_tables_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRING, 'UTF8', False), None, ),  # 0
    (1, TType.STRUCT, 'e', [TDBException, None], None, ),  # 1
)


class get_tables_for_database_args(object):
    """
    Attributes:
     - session
     - database_name

    """


    def __init__(self, session=None, database_name=None,):
        self.session = session
        self.database_name = database_name

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.session = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.database_name = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_tables_for_database_args')
        if self.session is not None:
            oprot.writeFieldBegin('session', TType.STRING, 1)
            oprot.writeString(self.session.encode('utf-8') if sys.version_info[0] == 2 else self.session)
            oprot.writeFieldEnd()
        if self.database_name is not None:
            oprot.writeFieldBegin('database_name', TType.STRING, 2)
            oprot.writeString(self.database_name.encode('utf-8') if sys.version_info[0] == 2 else self.database_name)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_tables_for_database_args)
get_tables_for_database_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'session', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'database_name', 'UTF8', None, ),  # 2
)


class get_tables_for_database_result(object):
    """
    Attributes:
     - success
     - e

    """


    def __init__(self, success=None, e=None,):
        self.success = success
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype293, _size290) = iprot.readListBegin()
                    for _i294 in range(_size290):
                        _elem295 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.success.append(_elem295)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TDBException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_tables_for_database_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRING, len(self.success))
            for iter296 in self.success:
                oprot.writeString(iter296.encode('utf-8') if sys.version_info[0] == 2 else iter296)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_tables_for_database_result)
get_tables_for_database_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRING, 'UTF8', False), None, ),  # 0
    (1, TType.STRUCT, 'e', [TDBException, None], None, ),  # 1
)


class get_physical_tables_args(object):
    """
    Attributes:
     - session

    """


    def __init__(self, session=None,):
        self.session = session

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.session = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_physical_tables_args')
        if self.session is not None:
            oprot.writeFieldBegin('session', TType.STRING, 1)
            oprot.writeString(self.session.encode('utf-8') if sys.version_info[0] == 2 else self.session)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_physical_tables_args)
get_physical_tables_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'session', 'UTF8', None, ),  # 1
)


class get_physical_tables_result(object):
    """
    Attributes:
     - success
     - e

    """


    def __init__(self, success=None, e=None,):
        self.success = success
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype300, _size297) = iprot.readListBegin()
                    for _i301 in range(_size297):
                        _elem302 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.success.append(_elem302)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TDBException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_physical_tables_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRING, len(self.success))
            for iter303 in self.success:
                oprot.writeString(iter303.encode('utf-8') if sys.version_info[0] == 2 else iter303)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_physical_tables_result)
get_physical_tables_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRING, 'UTF8', False), None, ),  # 0
    (1, TType.STRUCT, 'e', [TDBException, None], None, ),  # 1
)


class get_views_args(object):
    """
    Attributes:
     - session

    """


    def __init__(self, session=None,):
        self.session = session

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.session = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_views_args')
        if self.session is not None:
            oprot.writeFieldBegin('session', TType.STRING, 1)
            oprot.writeString(self.session.encode('utf-8') if sys.version_info[0] == 2 else self.session)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_views_args)
get_views_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'session', 'UTF8', None, ),  # 1
)


class get_views_result(object):
    """
    Attributes:
     - success
     - e

    """


    def __init__(self, success=None, e=None,):
        self.success = success
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype307, _size304) = iprot.readListBegin()
                    for _i308 in range(_size304):
                        _elem309 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.success.append(_elem309)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TDBException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_views_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRING, len(self.success))
            for iter310 in self.success:
                oprot.writeString(iter310.encode('utf-8') if sys.version_info[0] == 2 else iter310)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_views_result)
get_views_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRING, 'UTF8', False), None, ),  # 0
    (1, TType.STRUCT, 'e', [TDBException, None], None, ),  # 1
)


class get_tables_meta_args(object):
    """
    Attributes:
     - session

    """


    def __init__(self, session=None,):
        self.session = session

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.session = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_tables_meta_args')
        if self.session is not None:
            oprot.writeFieldBegin('session', TType.STRING, 1)
            oprot.writeString(self.session.encode('utf-8') if sys.version_info[0] == 2 else self.session)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_tables_meta_args)
get_tables_meta_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'session', 'UTF8', None, ),  # 1
)


class get_tables_meta_result(object):
    """
    Attributes:
     - success
     - e

    """


    def __init__(self, success=None, e=None,):
        self.success = success
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype314, _size311) = iprot.readListBegin()
                    for _i315 in range(_size311):
                        _elem316 = TTableMeta()
                        _elem316.read(iprot)
                        self.success.append(_elem316)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TDBException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_tables_meta_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter317 in self.success:
                iter317.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_tables_meta_result)
get_tables_meta_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT, [TTableMeta, None], False), None, ),  # 0
    (1, TType.STRUCT, 'e', [TDBException, None], None, ),  # 1
)


class get_table_details_args(object):
    """
    Attributes:
     - session
     - table_name

    """


    def __init__(self, session=None, table_name=None,):
        self.session = session
        self.table_name = table_name

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.session = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.table_name = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_table_details_args')
        if self.session is not None:
            oprot.writeFieldBegin('session', TType.STRING, 1)
            oprot.writeString(self.session.encode('utf-8') if sys.version_info[0] == 2 else self.session)
            oprot.writeFieldEnd()
        if self.table_name is not None:
            oprot.writeFieldBegin('table_name', TType.STRING, 2)
            oprot.writeString(self.table_name.encode('utf-8') if sys.version_info[0] == 2 else self.table_name)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_table_details_args)
get_table_details_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'session', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'table_name', 'UTF8', None, ),  # 2
)


class get_table_details_result(object):
    """
    Attributes:
     - success
     - e

    """


    def __init__(self, success=None, e=None,):
        self.success = success
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = TTableDetails()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TDBException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_table_details_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_table_details_result)
get_table_details_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [TTableDetails, None], None, ),  # 0
    (1, TType.STRUCT, 'e', [TDBException, None], None, ),  # 1
)


class get_table_details_for_database_args(object):
    """
    Attributes:
     - session
     - table_name
     - database_name

    """


    def __init__(self, session=None, table_name=None, database_name=None,):
        self.session = session
        self.table_name = table_name
        self.database_name = database_name

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.session = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.table_name = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.database_name = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_table_details_for_database_args')
        if self.session is not None:
            oprot.writeFieldBegin('session', TType.STRING, 1)
            oprot.writeString(self.session.encode('utf-8') if sys.version_info[0] == 2 else self.session)
            oprot.writeFieldEnd()
        if self.table_name is not None:
            oprot.writeFieldBegin('table_name', TType.STRING, 2)
            oprot.writeString(self.table_name.encode('utf-8') if sys.version_info[0] == 2 else self.table_name)
            oprot.writeFieldEnd()
        if self.database_name is not None:
            oprot.writeFieldBegin('database_name', TType.STRING, 3)
            oprot.writeString(self.database_name.encode('utf-8') if sys.version_info[0] == 2 else self.database_name)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_table_details_for_database_args)
get_table_details_for_database_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'session', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'table_name', 'UTF8', None, ),  # 2
    (3, TType.STRING, 'database_name', 'UTF8', None, ),  # 3
)


class get_table_details_for_database_result(object):
    """
    Attributes:
     - success
     - e

    """


    def __init__(self, success=None, e=None,):
        self.success = success
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = TTableDetails()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TDBException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_table_details_for_database_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_table_details_for_database_result)
get_table_details_for_database_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [TTableDetails, None], None, ),  # 0
    (1, TType.STRUCT, 'e', [TDBException, None], None, ),  # 1
)


class get_internal_table_details_args(object):
    """
    Attributes:
     - session
     - table_name
     - include_system_columns

    """


    def __init__(self, session=None, table_name=None, include_system_columns=True,):
        self.session = session
        self.table_name = table_name
        self.include_system_columns = include_system_columns

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.session = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.table_name = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.BOOL:
                    self.include_system_columns = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_internal_table_details_args')
        if self.session is not None:
            oprot.writeFieldBegin('session', TType.STRING, 1)
            oprot.writeString(self.session.encode('utf-8') if sys.version_info[0] == 2 else self.session)
            oprot.writeFieldEnd()
        if self.table_name is not None:
            oprot.writeFieldBegin('table_name', TType.STRING, 2)
            oprot.writeString(self.table_name.encode('utf-8') if sys.version_info[0] == 2 else self.table_name)
            oprot.writeFieldEnd()
        if self.include_system_columns is not None:
            oprot.writeFieldBegin('include_system_columns', TType.BOOL, 3)
            oprot.writeBool(self.include_system_columns)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_internal_table_details_args)
get_internal_table_details_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'session', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'table_name', 'UTF8', None, ),  # 2
    (3, TType.BOOL, 'include_system_columns', None, True, ),  # 3
)


class get_internal_table_details_result(object):
    """
    Attributes:
     - success
     - e

    """


    def __init__(self, success=None, e=None,):
        self.success = success
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = TTableDetails()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TDBException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_internal_table_details_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_internal_table_details_result)
get_internal_table_details_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [TTableDetails, None], None, ),  # 0
    (1, TType.STRUCT, 'e', [TDBException, None], None, ),  # 1
)


class get_internal_table_details_for_database_args(object):
    """
    Attributes:
     - session
     - table_name
     - database_name

    """


    def __init__(self, session=None, table_name=None, database_name=None,):
        self.session = session
        self.table_name = table_name
        self.database_name = database_name

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.session = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.table_name = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.database_name = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_internal_table_details_for_database_args')
        if self.session is not None:
            oprot.writeFieldBegin('session', TType.STRING, 1)
            oprot.writeString(self.session.encode('utf-8') if sys.version_info[0] == 2 else self.session)
            oprot.writeFieldEnd()
        if self.table_name is not None:
            oprot.writeFieldBegin('table_name', TType.STRING, 2)
            oprot.writeString(self.table_name.encode('utf-8') if sys.version_info[0] == 2 else self.table_name)
            oprot.writeFieldEnd()
        if self.database_name is not None:
            oprot.writeFieldBegin('database_name', TType.STRING, 3)
            oprot.writeString(self.database_name.encode('utf-8') if sys.version_info[0] == 2 else self.database_name)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_internal_table_details_for_database_args)
get_internal_table_details_for_database_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'session', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'table_name', 'UTF8', None, ),  # 2
    (3, TType.STRING, 'database_name', 'UTF8', None, ),  # 3
)


class get_internal_table_details_for_database_result(object):
    """
    Attributes:
     - success
     - e

    """


    def __init__(self, success=None, e=None,):
        self.success = success
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = TTableDetails()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TDBException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_internal_table_details_for_database_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_internal_table_details_for_database_result)
get_internal_table_details_for_database_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [TTableDetails, None], None, ),  # 0
    (1, TType.STRUCT, 'e', [TDBException, None], None, ),  # 1
)


class get_users_args(object):
    """
    Attributes:
     - session

    """


    def __init__(self, session=None,):
        self.session = session

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.session = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_users_args')
        if self.session is not None:
            oprot.writeFieldBegin('session', TType.STRING, 1)
            oprot.writeString(self.session.encode('utf-8') if sys.version_info[0] == 2 else self.session)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_users_args)
get_users_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'session', 'UTF8', None, ),  # 1
)


class get_users_result(object):
    """
    Attributes:
     - success
     - e

    """


    def __init__(self, success=None, e=None,):
        self.success = success
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype321, _size318) = iprot.readListBegin()
                    for _i322 in range(_size318):
                        _elem323 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.success.append(_elem323)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TDBException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_users_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRING, len(self.success))
            for iter324 in self.success:
                oprot.writeString(iter324.encode('utf-8') if sys.version_info[0] == 2 else iter324)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_users_result)
get_users_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRING, 'UTF8', False), None, ),  # 0
    (1, TType.STRUCT, 'e', [TDBException, None], None, ),  # 1
)


class get_databases_args(object):
    """
    Attributes:
     - session

    """


    def __init__(self, session=None,):
        self.session = session

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.session = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_databases_args')
        if self.session is not None:
            oprot.writeFieldBegin('session', TType.STRING, 1)
            oprot.writeString(self.session.encode('utf-8') if sys.version_info[0] == 2 else self.session)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_databases_args)
get_databases_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'session', 'UTF8', None, ),  # 1
)


class get_databases_result(object):
    """
    Attributes:
     - success
     - e

    """


    def __init__(self, success=None, e=None,):
        self.success = success
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype328, _size325) = iprot.readListBegin()
                    for _i329 in range(_size325):
                        _elem330 = TDBInfo()
                        _elem330.read(iprot)
                        self.success.append(_elem330)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TDBException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_databases_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter331 in self.success:
                iter331.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_databases_result)
get_databases_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT, [TDBInfo, None], False), None, ),  # 0
    (1, TType.STRUCT, 'e', [TDBException, None], None, ),  # 1
)


class get_version_args(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_version_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_version_args)
get_version_args.thrift_spec = (
)


class get_version_result(object):
    """
    Attributes:
     - success
     - e

    """


    def __init__(self, success=None, e=None,):
        self.success = success
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRING:
                    self.success = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TDBException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_version_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRING, 0)
            oprot.writeString(self.success.encode('utf-8') if sys.version_info[0] == 2 else self.success)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_version_result)
get_version_result.thrift_spec = (
    (0, TType.STRING, 'success', 'UTF8', None, ),  # 0
    (1, TType.STRUCT, 'e', [TDBException, None], None, ),  # 1
)


class start_heap_profile_args(object):
    """
    Attributes:
     - session

    """


    def __init__(self, session=None,):
        self.session = session

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.session = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('start_heap_profile_args')
        if self.session is not None:
            oprot.writeFieldBegin('session', TType.STRING, 1)
            oprot.writeString(self.session.encode('utf-8') if sys.version_info[0] == 2 else self.session)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(start_heap_profile_args)
start_heap_profile_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'session', 'UTF8', None, ),  # 1
)


class start_heap_profile_result(object):
    """
    Attributes:
     - e

    """


    def __init__(self, e=None,):
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TDBException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('start_heap_profile_result')
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(start_heap_profile_result)
start_heap_profile_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'e', [TDBException, None], None, ),  # 1
)


class stop_heap_profile_args(object):
    """
    Attributes:
     - session

    """


    def __init__(self, session=None,):
        self.session = session

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.session = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('stop_heap_profile_args')
        if self.session is not None:
            oprot.writeFieldBegin('session', TType.STRING, 1)
            oprot.writeString(self.session.encode('utf-8') if sys.version_info[0] == 2 else self.session)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(stop_heap_profile_args)
stop_heap_profile_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'session', 'UTF8', None, ),  # 1
)


class stop_heap_profile_result(object):
    """
    Attributes:
     - e

    """


    def __init__(self, e=None,):
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TDBException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('stop_heap_profile_result')
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(stop_heap_profile_result)
stop_heap_profile_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'e', [TDBException, None], None, ),  # 1
)


class get_heap_profile_args(object):
    """
    Attributes:
     - session

    """


    def __init__(self, session=None,):
        self.session = session

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.session = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_heap_profile_args')
        if self.session is not None:
            oprot.writeFieldBegin('session', TType.STRING, 1)
            oprot.writeString(self.session.encode('utf-8') if sys.version_info[0] == 2 else self.session)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_heap_profile_args)
get_heap_profile_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'session', 'UTF8', None, ),  # 1
)


class get_heap_profile_result(object):
    """
    Attributes:
     - success
     - e

    """


    def __init__(self, success=None, e=None,):
        self.success = success
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRING:
                    self.success = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TDBException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_heap_profile_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRING, 0)
            oprot.writeString(self.success.encode('utf-8') if sys.version_info[0] == 2 else self.success)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_heap_profile_result)
get_heap_profile_result.thrift_spec = (
    (0, TType.STRING, 'success', 'UTF8', None, ),  # 0
    (1, TType.STRUCT, 'e', [TDBException, None], None, ),  # 1
)


class get_memory_args(object):
    """
    Attributes:
     - session
     - memory_level

    """


    def __init__(self, session=None, memory_level=None,):
        self.session = session
        self.memory_level = memory_level

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.session = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.memory_level = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_memory_args')
        if self.session is not None:
            oprot.writeFieldBegin('session', TType.STRING, 1)
            oprot.writeString(self.session.encode('utf-8') if sys.version_info[0] == 2 else self.session)
            oprot.writeFieldEnd()
        if self.memory_level is not None:
            oprot.writeFieldBegin('memory_level', TType.STRING, 2)
            oprot.writeString(self.memory_level.encode('utf-8') if sys.version_info[0] == 2 else self.memory_level)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_memory_args)
get_memory_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'session', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'memory_level', 'UTF8', None, ),  # 2
)


class get_memory_result(object):
    """
    Attributes:
     - success
     - e

    """


    def __init__(self, success=None, e=None,):
        self.success = success
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype335, _size332) = iprot.readListBegin()
                    for _i336 in range(_size332):
                        _elem337 = TNodeMemoryInfo()
                        _elem337.read(iprot)
                        self.success.append(_elem337)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TDBException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_memory_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter338 in self.success:
                iter338.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_memory_result)
get_memory_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT, [TNodeMemoryInfo, None], False), None, ),  # 0
    (1, TType.STRUCT, 'e', [TDBException, None], None, ),  # 1
)


class clear_cpu_memory_args(object):
    """
    Attributes:
     - session

    """


    def __init__(self, session=None,):
        self.session = session

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.session = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('clear_cpu_memory_args')
        if self.session is not None:
            oprot.writeFieldBegin('session', TType.STRING, 1)
            oprot.writeString(self.session.encode('utf-8') if sys.version_info[0] == 2 else self.session)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(clear_cpu_memory_args)
clear_cpu_memory_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'session', 'UTF8', None, ),  # 1
)


class clear_cpu_memory_result(object):
    """
    Attributes:
     - e

    """


    def __init__(self, e=None,):
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TDBException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('clear_cpu_memory_result')
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(clear_cpu_memory_result)
clear_cpu_memory_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'e', [TDBException, None], None, ),  # 1
)


class clear_gpu_memory_args(object):
    """
    Attributes:
     - session

    """


    def __init__(self, session=None,):
        self.session = session

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.session = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('clear_gpu_memory_args')
        if self.session is not None:
            oprot.writeFieldBegin('session', TType.STRING, 1)
            oprot.writeString(self.session.encode('utf-8') if sys.version_info[0] == 2 else self.session)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(clear_gpu_memory_args)
clear_gpu_memory_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'session', 'UTF8', None, ),  # 1
)


class clear_gpu_memory_result(object):
    """
    Attributes:
     - e

    """


    def __init__(self, e=None,):
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TDBException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('clear_gpu_memory_result')
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(clear_gpu_memory_result)
clear_gpu_memory_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'e', [TDBException, None], None, ),  # 1
)


class set_cur_session_args(object):
    """
    Attributes:
     - parent_session
     - leaf_session
     - start_time_str
     - label
     - for_running_query_kernel

    """


    def __init__(self, parent_session=None, leaf_session=None, start_time_str=None, label=None, for_running_query_kernel=None,):
        self.parent_session = parent_session
        self.leaf_session = leaf_session
        self.start_time_str = start_time_str
        self.label = label
        self.for_running_query_kernel = for_running_query_kernel

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.parent_session = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.leaf_session = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.start_time_str = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.label = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.BOOL:
                    self.for_running_query_kernel = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('set_cur_session_args')
        if self.parent_session is not None:
            oprot.writeFieldBegin('parent_session', TType.STRING, 1)
            oprot.writeString(self.parent_session.encode('utf-8') if sys.version_info[0] == 2 else self.parent_session)
            oprot.writeFieldEnd()
        if self.leaf_session is not None:
            oprot.writeFieldBegin('leaf_session', TType.STRING, 2)
            oprot.writeString(self.leaf_session.encode('utf-8') if sys.version_info[0] == 2 else self.leaf_session)
            oprot.writeFieldEnd()
        if self.start_time_str is not None:
            oprot.writeFieldBegin('start_time_str', TType.STRING, 3)
            oprot.writeString(self.start_time_str.encode('utf-8') if sys.version_info[0] == 2 else self.start_time_str)
            oprot.writeFieldEnd()
        if self.label is not None:
            oprot.writeFieldBegin('label', TType.STRING, 4)
            oprot.writeString(self.label.encode('utf-8') if sys.version_info[0] == 2 else self.label)
            oprot.writeFieldEnd()
        if self.for_running_query_kernel is not None:
            oprot.writeFieldBegin('for_running_query_kernel', TType.BOOL, 5)
            oprot.writeBool(self.for_running_query_kernel)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(set_cur_session_args)
set_cur_session_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'parent_session', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'leaf_session', 'UTF8', None, ),  # 2
    (3, TType.STRING, 'start_time_str', 'UTF8', None, ),  # 3
    (4, TType.STRING, 'label', 'UTF8', None, ),  # 4
    (5, TType.BOOL, 'for_running_query_kernel', None, None, ),  # 5
)


class set_cur_session_result(object):
    """
    Attributes:
     - e

    """


    def __init__(self, e=None,):
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TDBException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('set_cur_session_result')
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(set_cur_session_result)
set_cur_session_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'e', [TDBException, None], None, ),  # 1
)


class invalidate_cur_session_args(object):
    """
    Attributes:
     - parent_session
     - leaf_session
     - start_time_str
     - label
     - for_running_query_kernel

    """


    def __init__(self, parent_session=None, leaf_session=None, start_time_str=None, label=None, for_running_query_kernel=None,):
        self.parent_session = parent_session
        self.leaf_session = leaf_session
        self.start_time_str = start_time_str
        self.label = label
        self.for_running_query_kernel = for_running_query_kernel

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.parent_session = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.leaf_session = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.start_time_str = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.label = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.BOOL:
                    self.for_running_query_kernel = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('invalidate_cur_session_args')
        if self.parent_session is not None:
            oprot.writeFieldBegin('parent_session', TType.STRING, 1)
            oprot.writeString(self.parent_session.encode('utf-8') if sys.version_info[0] == 2 else self.parent_session)
            oprot.writeFieldEnd()
        if self.leaf_session is not None:
            oprot.writeFieldBegin('leaf_session', TType.STRING, 2)
            oprot.writeString(self.leaf_session.encode('utf-8') if sys.version_info[0] == 2 else self.leaf_session)
            oprot.writeFieldEnd()
        if self.start_time_str is not None:
            oprot.writeFieldBegin('start_time_str', TType.STRING, 3)
            oprot.writeString(self.start_time_str.encode('utf-8') if sys.version_info[0] == 2 else self.start_time_str)
            oprot.writeFieldEnd()
        if self.label is not None:
            oprot.writeFieldBegin('label', TType.STRING, 4)
            oprot.writeString(self.label.encode('utf-8') if sys.version_info[0] == 2 else self.label)
            oprot.writeFieldEnd()
        if self.for_running_query_kernel is not None:
            oprot.writeFieldBegin('for_running_query_kernel', TType.BOOL, 5)
            oprot.writeBool(self.for_running_query_kernel)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(invalidate_cur_session_args)
invalidate_cur_session_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'parent_session', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'leaf_session', 'UTF8', None, ),  # 2
    (3, TType.STRING, 'start_time_str', 'UTF8', None, ),  # 3
    (4, TType.STRING, 'label', 'UTF8', None, ),  # 4
    (5, TType.BOOL, 'for_running_query_kernel', None, None, ),  # 5
)


class invalidate_cur_session_result(object):
    """
    Attributes:
     - e

    """


    def __init__(self, e=None,):
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TDBException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('invalidate_cur_session_result')
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(invalidate_cur_session_result)
invalidate_cur_session_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'e', [TDBException, None], None, ),  # 1
)


class set_table_epoch_args(object):
    """
    Attributes:
     - session
     - db_id
     - table_id
     - new_epoch

    """


    def __init__(self, session=None, db_id=None, table_id=None, new_epoch=None,):
        self.session = session
        self.db_id = db_id
        self.table_id = table_id
        self.new_epoch = new_epoch

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.session = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.db_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.table_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I32:
                    self.new_epoch = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('set_table_epoch_args')
        if self.session is not None:
            oprot.writeFieldBegin('session', TType.STRING, 1)
            oprot.writeString(self.session.encode('utf-8') if sys.version_info[0] == 2 else self.session)
            oprot.writeFieldEnd()
        if self.db_id is not None:
            oprot.writeFieldBegin('db_id', TType.I32, 2)
            oprot.writeI32(self.db_id)
            oprot.writeFieldEnd()
        if self.table_id is not None:
            oprot.writeFieldBegin('table_id', TType.I32, 3)
            oprot.writeI32(self.table_id)
            oprot.writeFieldEnd()
        if self.new_epoch is not None:
            oprot.writeFieldBegin('new_epoch', TType.I32, 4)
            oprot.writeI32(self.new_epoch)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(set_table_epoch_args)
set_table_epoch_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'session', 'UTF8', None, ),  # 1
    (2, TType.I32, 'db_id', None, None, ),  # 2
    (3, TType.I32, 'table_id', None, None, ),  # 3
    (4, TType.I32, 'new_epoch', None, None, ),  # 4
)


class set_table_epoch_result(object):
    """
    Attributes:
     - e

    """


    def __init__(self, e=None,):
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TDBException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('set_table_epoch_result')
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(set_table_epoch_result)
set_table_epoch_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'e', [TDBException, None], None, ),  # 1
)


class set_table_epoch_by_name_args(object):
    """
    Attributes:
     - session
     - table_name
     - new_epoch

    """


    def __init__(self, session=None, table_name=None, new_epoch=None,):
        self.session = session
        self.table_name = table_name
        self.new_epoch = new_epoch

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.session = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.table_name = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.new_epoch = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('set_table_epoch_by_name_args')
        if self.session is not None:
            oprot.writeFieldBegin('session', TType.STRING, 1)
            oprot.writeString(self.session.encode('utf-8') if sys.version_info[0] == 2 else self.session)
            oprot.writeFieldEnd()
        if self.table_name is not None:
            oprot.writeFieldBegin('table_name', TType.STRING, 2)
            oprot.writeString(self.table_name.encode('utf-8') if sys.version_info[0] == 2 else self.table_name)
            oprot.writeFieldEnd()
        if self.new_epoch is not None:
            oprot.writeFieldBegin('new_epoch', TType.I32, 3)
            oprot.writeI32(self.new_epoch)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(set_table_epoch_by_name_args)
set_table_epoch_by_name_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'session', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'table_name', 'UTF8', None, ),  # 2
    (3, TType.I32, 'new_epoch', None, None, ),  # 3
)


class set_table_epoch_by_name_result(object):
    """
    Attributes:
     - e

    """


    def __init__(self, e=None,):
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TDBException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('set_table_epoch_by_name_result')
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(set_table_epoch_by_name_result)
set_table_epoch_by_name_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'e', [TDBException, None], None, ),  # 1
)


class get_table_epoch_args(object):
    """
    Attributes:
     - session
     - db_id
     - table_id

    """


    def __init__(self, session=None, db_id=None, table_id=None,):
        self.session = session
        self.db_id = db_id
        self.table_id = table_id

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.session = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.db_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.table_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_table_epoch_args')
        if self.session is not None:
            oprot.writeFieldBegin('session', TType.STRING, 1)
            oprot.writeString(self.session.encode('utf-8') if sys.version_info[0] == 2 else self.session)
            oprot.writeFieldEnd()
        if self.db_id is not None:
            oprot.writeFieldBegin('db_id', TType.I32, 2)
            oprot.writeI32(self.db_id)
            oprot.writeFieldEnd()
        if self.table_id is not None:
            oprot.writeFieldBegin('table_id', TType.I32, 3)
            oprot.writeI32(self.table_id)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_table_epoch_args)
get_table_epoch_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'session', 'UTF8', None, ),  # 1
    (2, TType.I32, 'db_id', None, None, ),  # 2
    (3, TType.I32, 'table_id', None, None, ),  # 3
)


class get_table_epoch_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_table_epoch_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_table_epoch_result)
get_table_epoch_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
)


class get_table_epoch_by_name_args(object):
    """
    Attributes:
     - session
     - table_name

    """


    def __init__(self, session=None, table_name=None,):
        self.session = session
        self.table_name = table_name

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.session = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.table_name = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_table_epoch_by_name_args')
        if self.session is not None:
            oprot.writeFieldBegin('session', TType.STRING, 1)
            oprot.writeString(self.session.encode('utf-8') if sys.version_info[0] == 2 else self.session)
            oprot.writeFieldEnd()
        if self.table_name is not None:
            oprot.writeFieldBegin('table_name', TType.STRING, 2)
            oprot.writeString(self.table_name.encode('utf-8') if sys.version_info[0] == 2 else self.table_name)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_table_epoch_by_name_args)
get_table_epoch_by_name_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'session', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'table_name', 'UTF8', None, ),  # 2
)


class get_table_epoch_by_name_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_table_epoch_by_name_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_table_epoch_by_name_result)
get_table_epoch_by_name_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
)


class get_table_epochs_args(object):
    """
    Attributes:
     - session
     - db_id
     - table_id

    """


    def __init__(self, session=None, db_id=None, table_id=None,):
        self.session = session
        self.db_id = db_id
        self.table_id = table_id

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.session = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.db_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.table_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_table_epochs_args')
        if self.session is not None:
            oprot.writeFieldBegin('session', TType.STRING, 1)
            oprot.writeString(self.session.encode('utf-8') if sys.version_info[0] == 2 else self.session)
            oprot.writeFieldEnd()
        if self.db_id is not None:
            oprot.writeFieldBegin('db_id', TType.I32, 2)
            oprot.writeI32(self.db_id)
            oprot.writeFieldEnd()
        if self.table_id is not None:
            oprot.writeFieldBegin('table_id', TType.I32, 3)
            oprot.writeI32(self.table_id)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_table_epochs_args)
get_table_epochs_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'session', 'UTF8', None, ),  # 1
    (2, TType.I32, 'db_id', None, None, ),  # 2
    (3, TType.I32, 'table_id', None, None, ),  # 3
)


class get_table_epochs_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype342, _size339) = iprot.readListBegin()
                    for _i343 in range(_size339):
                        _elem344 = TTableEpochInfo()
                        _elem344.read(iprot)
                        self.success.append(_elem344)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_table_epochs_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter345 in self.success:
                iter345.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_table_epochs_result)
get_table_epochs_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT, [TTableEpochInfo, None], False), None, ),  # 0
)


class set_table_epochs_args(object):
    """
    Attributes:
     - session
     - db_id
     - table_epochs

    """


    def __init__(self, session=None, db_id=None, table_epochs=None,):
        self.session = session
        self.db_id = db_id
        self.table_epochs = table_epochs

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.session = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.db_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.table_epochs = []
                    (_etype349, _size346) = iprot.readListBegin()
                    for _i350 in range(_size346):
                        _elem351 = TTableEpochInfo()
                        _elem351.read(iprot)
                        self.table_epochs.append(_elem351)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('set_table_epochs_args')
        if self.session is not None:
            oprot.writeFieldBegin('session', TType.STRING, 1)
            oprot.writeString(self.session.encode('utf-8') if sys.version_info[0] == 2 else self.session)
            oprot.writeFieldEnd()
        if self.db_id is not None:
            oprot.writeFieldBegin('db_id', TType.I32, 2)
            oprot.writeI32(self.db_id)
            oprot.writeFieldEnd()
        if self.table_epochs is not None:
            oprot.writeFieldBegin('table_epochs', TType.LIST, 3)
            oprot.writeListBegin(TType.STRUCT, len(self.table_epochs))
            for iter352 in self.table_epochs:
                iter352.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(set_table_epochs_args)
set_table_epochs_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'session', 'UTF8', None, ),  # 1
    (2, TType.I32, 'db_id', None, None, ),  # 2
    (3, TType.LIST, 'table_epochs', (TType.STRUCT, [TTableEpochInfo, None], False), None, ),  # 3
)


class set_table_epochs_result(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('set_table_epochs_result')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(set_table_epochs_result)
set_table_epochs_result.thrift_spec = (
)


class get_session_info_args(object):
    """
    Attributes:
     - session

    """


    def __init__(self, session=None,):
        self.session = session

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.session = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_session_info_args')
        if self.session is not None:
            oprot.writeFieldBegin('session', TType.STRING, 1)
            oprot.writeString(self.session.encode('utf-8') if sys.version_info[0] == 2 else self.session)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_session_info_args)
get_session_info_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'session', 'UTF8', None, ),  # 1
)


class get_session_info_result(object):
    """
    Attributes:
     - success
     - e

    """


    def __init__(self, success=None, e=None,):
        self.success = success
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = TSessionInfo()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TDBException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_session_info_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_session_info_result)
get_session_info_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [TSessionInfo, None], None, ),  # 0
    (1, TType.STRUCT, 'e', [TDBException, None], None, ),  # 1
)


class get_queries_info_args(object):
    """
    Attributes:
     - session

    """


    def __init__(self, session=None,):
        self.session = session

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.session = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_queries_info_args')
        if self.session is not None:
            oprot.writeFieldBegin('session', TType.STRING, 1)
            oprot.writeString(self.session.encode('utf-8') if sys.version_info[0] == 2 else self.session)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_queries_info_args)
get_queries_info_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'session', 'UTF8', None, ),  # 1
)


class get_queries_info_result(object):
    """
    Attributes:
     - success
     - e

    """


    def __init__(self, success=None, e=None,):
        self.success = success
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype356, _size353) = iprot.readListBegin()
                    for _i357 in range(_size353):
                        _elem358 = TQueryInfo()
                        _elem358.read(iprot)
                        self.success.append(_elem358)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TDBException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_queries_info_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter359 in self.success:
                iter359.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_queries_info_result)
get_queries_info_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT, [TQueryInfo, None], False), None, ),  # 0
    (1, TType.STRUCT, 'e', [TDBException, None], None, ),  # 1
)


class set_leaf_info_args(object):
    """
    Attributes:
     - session
     - leaf_info

    """


    def __init__(self, session=None, leaf_info=None,):
        self.session = session
        self.leaf_info = leaf_info

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.session = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.leaf_info = TLeafInfo()
                    self.leaf_info.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('set_leaf_info_args')
        if self.session is not None:
            oprot.writeFieldBegin('session', TType.STRING, 1)
            oprot.writeString(self.session.encode('utf-8') if sys.version_info[0] == 2 else self.session)
            oprot.writeFieldEnd()
        if self.leaf_info is not None:
            oprot.writeFieldBegin('leaf_info', TType.STRUCT, 2)
            self.leaf_info.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(set_leaf_info_args)
set_leaf_info_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'session', 'UTF8', None, ),  # 1
    (2, TType.STRUCT, 'leaf_info', [TLeafInfo, None], None, ),  # 2
)


class set_leaf_info_result(object):
    """
    Attributes:
     - e

    """


    def __init__(self, e=None,):
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TDBException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('set_leaf_info_result')
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(set_leaf_info_result)
set_leaf_info_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'e', [TDBException, None], None, ),  # 1
)


class sql_execute_args(object):
    """
    Attributes:
     - session
     - query
     - column_format
     - nonce
     - first_n
     - at_most_n

    """


    def __init__(self, session=None, query=None, column_format=None, nonce=None, first_n=-1, at_most_n=-1,):
        self.session = session
        self.query = query
        self.column_format = column_format
        self.nonce = nonce
        self.first_n = first_n
        self.at_most_n = at_most_n

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.session = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.query = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.BOOL:
                    self.column_format = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.nonce = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.I32:
                    self.first_n = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.I32:
                    self.at_most_n = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('sql_execute_args')
        if self.session is not None:
            oprot.writeFieldBegin('session', TType.STRING, 1)
            oprot.writeString(self.session.encode('utf-8') if sys.version_info[0] == 2 else self.session)
            oprot.writeFieldEnd()
        if self.query is not None:
            oprot.writeFieldBegin('query', TType.STRING, 2)
            oprot.writeString(self.query.encode('utf-8') if sys.version_info[0] == 2 else self.query)
            oprot.writeFieldEnd()
        if self.column_format is not None:
            oprot.writeFieldBegin('column_format', TType.BOOL, 3)
            oprot.writeBool(self.column_format)
            oprot.writeFieldEnd()
        if self.nonce is not None:
            oprot.writeFieldBegin('nonce', TType.STRING, 4)
            oprot.writeString(self.nonce.encode('utf-8') if sys.version_info[0] == 2 else self.nonce)
            oprot.writeFieldEnd()
        if self.first_n is not None:
            oprot.writeFieldBegin('first_n', TType.I32, 5)
            oprot.writeI32(self.first_n)
            oprot.writeFieldEnd()
        if self.at_most_n is not None:
            oprot.writeFieldBegin('at_most_n', TType.I32, 6)
            oprot.writeI32(self.at_most_n)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(sql_execute_args)
sql_execute_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'session', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'query', 'UTF8', None, ),  # 2
    (3, TType.BOOL, 'column_format', None, None, ),  # 3
    (4, TType.STRING, 'nonce', 'UTF8', None, ),  # 4
    (5, TType.I32, 'first_n', None, -1, ),  # 5
    (6, TType.I32, 'at_most_n', None, -1, ),  # 6
)


class sql_execute_result(object):
    """
    Attributes:
     - success
     - e

    """


    def __init__(self, success=None, e=None,):
        self.success = success
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = TQueryResult()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TDBException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('sql_execute_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(sql_execute_result)
sql_execute_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [TQueryResult, None], None, ),  # 0
    (1, TType.STRUCT, 'e', [TDBException, None], None, ),  # 1
)


class sql_execute_df_args(object):
    """
    Attributes:
     - session
     - query
     - device_type
     - device_id
     - first_n
     - transport_method

    """


    def __init__(self, session=None, query=None, device_type=None, device_id=0, first_n=-1, transport_method=None,):
        self.session = session
        self.query = query
        self.device_type = device_type
        self.device_id = device_id
        self.first_n = first_n
        self.transport_method = transport_method

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.session = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.query = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.device_type = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I32:
                    self.device_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.I32:
                    self.first_n = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.I32:
                    self.transport_method = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('sql_execute_df_args')
        if self.session is not None:
            oprot.writeFieldBegin('session', TType.STRING, 1)
            oprot.writeString(self.session.encode('utf-8') if sys.version_info[0] == 2 else self.session)
            oprot.writeFieldEnd()
        if self.query is not None:
            oprot.writeFieldBegin('query', TType.STRING, 2)
            oprot.writeString(self.query.encode('utf-8') if sys.version_info[0] == 2 else self.query)
            oprot.writeFieldEnd()
        if self.device_type is not None:
            oprot.writeFieldBegin('device_type', TType.I32, 3)
            oprot.writeI32(self.device_type)
            oprot.writeFieldEnd()
        if self.device_id is not None:
            oprot.writeFieldBegin('device_id', TType.I32, 4)
            oprot.writeI32(self.device_id)
            oprot.writeFieldEnd()
        if self.first_n is not None:
            oprot.writeFieldBegin('first_n', TType.I32, 5)
            oprot.writeI32(self.first_n)
            oprot.writeFieldEnd()
        if self.transport_method is not None:
            oprot.writeFieldBegin('transport_method', TType.I32, 6)
            oprot.writeI32(self.transport_method)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(sql_execute_df_args)
sql_execute_df_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'session', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'query', 'UTF8', None, ),  # 2
    (3, TType.I32, 'device_type', None, None, ),  # 3
    (4, TType.I32, 'device_id', None, 0, ),  # 4
    (5, TType.I32, 'first_n', None, -1, ),  # 5
    (6, TType.I32, 'transport_method', None, None, ),  # 6
)


class sql_execute_df_result(object):
    """
    Attributes:
     - success
     - e

    """


    def __init__(self, success=None, e=None,):
        self.success = success
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = TDataFrame()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TDBException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('sql_execute_df_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(sql_execute_df_result)
sql_execute_df_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [TDataFrame, None], None, ),  # 0
    (1, TType.STRUCT, 'e', [TDBException, None], None, ),  # 1
)


class sql_execute_gdf_args(object):
    """
    Attributes:
     - session
     - query
     - device_id
     - first_n

    """


    def __init__(self, session=None, query=None, device_id=0, first_n=-1,):
        self.session = session
        self.query = query
        self.device_id = device_id
        self.first_n = first_n

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.session = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.query = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.device_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I32:
                    self.first_n = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('sql_execute_gdf_args')
        if self.session is not None:
            oprot.writeFieldBegin('session', TType.STRING, 1)
            oprot.writeString(self.session.encode('utf-8') if sys.version_info[0] == 2 else self.session)
            oprot.writeFieldEnd()
        if self.query is not None:
            oprot.writeFieldBegin('query', TType.STRING, 2)
            oprot.writeString(self.query.encode('utf-8') if sys.version_info[0] == 2 else self.query)
            oprot.writeFieldEnd()
        if self.device_id is not None:
            oprot.writeFieldBegin('device_id', TType.I32, 3)
            oprot.writeI32(self.device_id)
            oprot.writeFieldEnd()
        if self.first_n is not None:
            oprot.writeFieldBegin('first_n', TType.I32, 4)
            oprot.writeI32(self.first_n)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(sql_execute_gdf_args)
sql_execute_gdf_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'session', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'query', 'UTF8', None, ),  # 2
    (3, TType.I32, 'device_id', None, 0, ),  # 3
    (4, TType.I32, 'first_n', None, -1, ),  # 4
)


class sql_execute_gdf_result(object):
    """
    Attributes:
     - success
     - e

    """


    def __init__(self, success=None, e=None,):
        self.success = success
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = TDataFrame()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TDBException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('sql_execute_gdf_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(sql_execute_gdf_result)
sql_execute_gdf_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [TDataFrame, None], None, ),  # 0
    (1, TType.STRUCT, 'e', [TDBException, None], None, ),  # 1
)


class deallocate_df_args(object):
    """
    Attributes:
     - session
     - df
     - device_type
     - device_id

    """


    def __init__(self, session=None, df=None, device_type=None, device_id=0,):
        self.session = session
        self.df = df
        self.device_type = device_type
        self.device_id = device_id

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.session = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.df = TDataFrame()
                    self.df.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.device_type = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I32:
                    self.device_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('deallocate_df_args')
        if self.session is not None:
            oprot.writeFieldBegin('session', TType.STRING, 1)
            oprot.writeString(self.session.encode('utf-8') if sys.version_info[0] == 2 else self.session)
            oprot.writeFieldEnd()
        if self.df is not None:
            oprot.writeFieldBegin('df', TType.STRUCT, 2)
            self.df.write(oprot)
            oprot.writeFieldEnd()
        if self.device_type is not None:
            oprot.writeFieldBegin('device_type', TType.I32, 3)
            oprot.writeI32(self.device_type)
            oprot.writeFieldEnd()
        if self.device_id is not None:
            oprot.writeFieldBegin('device_id', TType.I32, 4)
            oprot.writeI32(self.device_id)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(deallocate_df_args)
deallocate_df_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'session', 'UTF8', None, ),  # 1
    (2, TType.STRUCT, 'df', [TDataFrame, None], None, ),  # 2
    (3, TType.I32, 'device_type', None, None, ),  # 3
    (4, TType.I32, 'device_id', None, 0, ),  # 4
)


class deallocate_df_result(object):
    """
    Attributes:
     - e

    """


    def __init__(self, e=None,):
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TDBException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('deallocate_df_result')
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(deallocate_df_result)
deallocate_df_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'e', [TDBException, None], None, ),  # 1
)


class interrupt_args(object):
    """
    Attributes:
     - query_session
     - interrupt_session

    """


    def __init__(self, query_session=None, interrupt_session=None,):
        self.query_session = query_session
        self.interrupt_session = interrupt_session

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.query_session = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.interrupt_session = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('interrupt_args')
        if self.query_session is not None:
            oprot.writeFieldBegin('query_session', TType.STRING, 1)
            oprot.writeString(self.query_session.encode('utf-8') if sys.version_info[0] == 2 else self.query_session)
            oprot.writeFieldEnd()
        if self.interrupt_session is not None:
            oprot.writeFieldBegin('interrupt_session', TType.STRING, 2)
            oprot.writeString(self.interrupt_session.encode('utf-8') if sys.version_info[0] == 2 else self.interrupt_session)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(interrupt_args)
interrupt_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'query_session', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'interrupt_session', 'UTF8', None, ),  # 2
)


class interrupt_result(object):
    """
    Attributes:
     - e

    """


    def __init__(self, e=None,):
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TDBException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('interrupt_result')
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(interrupt_result)
interrupt_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'e', [TDBException, None], None, ),  # 1
)


class sql_validate_args(object):
    """
    Attributes:
     - session
     - query

    """


    def __init__(self, session=None, query=None,):
        self.session = session
        self.query = query

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.session = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.query = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('sql_validate_args')
        if self.session is not None:
            oprot.writeFieldBegin('session', TType.STRING, 1)
            oprot.writeString(self.session.encode('utf-8') if sys.version_info[0] == 2 else self.session)
            oprot.writeFieldEnd()
        if self.query is not None:
            oprot.writeFieldBegin('query', TType.STRING, 2)
            oprot.writeString(self.query.encode('utf-8') if sys.version_info[0] == 2 else self.query)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(sql_validate_args)
sql_validate_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'session', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'query', 'UTF8', None, ),  # 2
)


class sql_validate_result(object):
    """
    Attributes:
     - success
     - e

    """


    def __init__(self, success=None, e=None,):
        self.success = success
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype363, _size360) = iprot.readListBegin()
                    for _i364 in range(_size360):
                        _elem365 = TColumnType()
                        _elem365.read(iprot)
                        self.success.append(_elem365)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TDBException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('sql_validate_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter366 in self.success:
                iter366.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(sql_validate_result)
sql_validate_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT, [TColumnType, None], False), None, ),  # 0
    (1, TType.STRUCT, 'e', [TDBException, None], None, ),  # 1
)


class get_completion_hints_args(object):
    """
    Attributes:
     - session
     - sql
     - cursor

    """


    def __init__(self, session=None, sql=None, cursor=None,):
        self.session = session
        self.sql = sql
        self.cursor = cursor

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.session = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.sql = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.cursor = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_completion_hints_args')
        if self.session is not None:
            oprot.writeFieldBegin('session', TType.STRING, 1)
            oprot.writeString(self.session.encode('utf-8') if sys.version_info[0] == 2 else self.session)
            oprot.writeFieldEnd()
        if self.sql is not None:
            oprot.writeFieldBegin('sql', TType.STRING, 2)
            oprot.writeString(self.sql.encode('utf-8') if sys.version_info[0] == 2 else self.sql)
            oprot.writeFieldEnd()
        if self.cursor is not None:
            oprot.writeFieldBegin('cursor', TType.I32, 3)
            oprot.writeI32(self.cursor)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_completion_hints_args)
get_completion_hints_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'session', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'sql', 'UTF8', None, ),  # 2
    (3, TType.I32, 'cursor', None, None, ),  # 3
)


class get_completion_hints_result(object):
    """
    Attributes:
     - success
     - e

    """


    def __init__(self, success=None, e=None,):
        self.success = success
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype370, _size367) = iprot.readListBegin()
                    for _i371 in range(_size367):
                        _elem372 = heavydb.completion_hints.ttypes.TCompletionHint()
                        _elem372.read(iprot)
                        self.success.append(_elem372)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TDBException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_completion_hints_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter373 in self.success:
                iter373.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_completion_hints_result)
get_completion_hints_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT, [heavydb.completion_hints.ttypes.TCompletionHint, None], False), None,),  # 0
    (1, TType.STRUCT, 'e', [TDBException, None], None, ),  # 1
)


class set_execution_mode_args(object):
    """
    Attributes:
     - session
     - mode

    """


    def __init__(self, session=None, mode=None,):
        self.session = session
        self.mode = mode

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.session = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.mode = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('set_execution_mode_args')
        if self.session is not None:
            oprot.writeFieldBegin('session', TType.STRING, 1)
            oprot.writeString(self.session.encode('utf-8') if sys.version_info[0] == 2 else self.session)
            oprot.writeFieldEnd()
        if self.mode is not None:
            oprot.writeFieldBegin('mode', TType.I32, 2)
            oprot.writeI32(self.mode)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(set_execution_mode_args)
set_execution_mode_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'session', 'UTF8', None, ),  # 1
    (2, TType.I32, 'mode', None, None, ),  # 2
)


class set_execution_mode_result(object):
    """
    Attributes:
     - e

    """


    def __init__(self, e=None,):
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TDBException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('set_execution_mode_result')
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(set_execution_mode_result)
set_execution_mode_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'e', [TDBException, None], None, ),  # 1
)


class render_vega_args(object):
    """
    Attributes:
     - session
     - widget_id
     - vega_json
     - compression_level
     - nonce

    """


    def __init__(self, session=None, widget_id=None, vega_json=None, compression_level=None, nonce=None,):
        self.session = session
        self.widget_id = widget_id
        self.vega_json = vega_json
        self.compression_level = compression_level
        self.nonce = nonce

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.session = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.widget_id = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.vega_json = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I32:
                    self.compression_level = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRING:
                    self.nonce = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('render_vega_args')
        if self.session is not None:
            oprot.writeFieldBegin('session', TType.STRING, 1)
            oprot.writeString(self.session.encode('utf-8') if sys.version_info[0] == 2 else self.session)
            oprot.writeFieldEnd()
        if self.widget_id is not None:
            oprot.writeFieldBegin('widget_id', TType.I64, 2)
            oprot.writeI64(self.widget_id)
            oprot.writeFieldEnd()
        if self.vega_json is not None:
            oprot.writeFieldBegin('vega_json', TType.STRING, 3)
            oprot.writeString(self.vega_json.encode('utf-8') if sys.version_info[0] == 2 else self.vega_json)
            oprot.writeFieldEnd()
        if self.compression_level is not None:
            oprot.writeFieldBegin('compression_level', TType.I32, 4)
            oprot.writeI32(self.compression_level)
            oprot.writeFieldEnd()
        if self.nonce is not None:
            oprot.writeFieldBegin('nonce', TType.STRING, 5)
            oprot.writeString(self.nonce.encode('utf-8') if sys.version_info[0] == 2 else self.nonce)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(render_vega_args)
render_vega_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'session', 'UTF8', None, ),  # 1
    (2, TType.I64, 'widget_id', None, None, ),  # 2
    (3, TType.STRING, 'vega_json', 'UTF8', None, ),  # 3
    (4, TType.I32, 'compression_level', None, None, ),  # 4
    (5, TType.STRING, 'nonce', 'UTF8', None, ),  # 5
)


class render_vega_result(object):
    """
    Attributes:
     - success
     - e

    """


    def __init__(self, success=None, e=None,):
        self.success = success
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = TRenderResult()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TDBException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('render_vega_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(render_vega_result)
render_vega_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [TRenderResult, None], None, ),  # 0
    (1, TType.STRUCT, 'e', [TDBException, None], None, ),  # 1
)


class get_result_row_for_pixel_args(object):
    """
    Attributes:
     - session
     - widget_id
     - pixel
     - table_col_names
     - column_format
     - pixelRadius
     - nonce

    """


    def __init__(self, session=None, widget_id=None, pixel=None, table_col_names=None, column_format=None, pixelRadius=None, nonce=None,):
        self.session = session
        self.widget_id = widget_id
        self.pixel = pixel
        self.table_col_names = table_col_names
        self.column_format = column_format
        self.pixelRadius = pixelRadius
        self.nonce = nonce

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.session = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.widget_id = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.pixel = TPixel()
                    self.pixel.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.MAP:
                    self.table_col_names = {}
                    (_ktype375, _vtype376, _size374) = iprot.readMapBegin()
                    for _i378 in range(_size374):
                        _key379 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        _val380 = []
                        (_etype384, _size381) = iprot.readListBegin()
                        for _i385 in range(_size381):
                            _elem386 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                            _val380.append(_elem386)
                        iprot.readListEnd()
                        self.table_col_names[_key379] = _val380
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.BOOL:
                    self.column_format = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.I32:
                    self.pixelRadius = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.STRING:
                    self.nonce = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_result_row_for_pixel_args')
        if self.session is not None:
            oprot.writeFieldBegin('session', TType.STRING, 1)
            oprot.writeString(self.session.encode('utf-8') if sys.version_info[0] == 2 else self.session)
            oprot.writeFieldEnd()
        if self.widget_id is not None:
            oprot.writeFieldBegin('widget_id', TType.I64, 2)
            oprot.writeI64(self.widget_id)
            oprot.writeFieldEnd()
        if self.pixel is not None:
            oprot.writeFieldBegin('pixel', TType.STRUCT, 3)
            self.pixel.write(oprot)
            oprot.writeFieldEnd()
        if self.table_col_names is not None:
            oprot.writeFieldBegin('table_col_names', TType.MAP, 4)
            oprot.writeMapBegin(TType.STRING, TType.LIST, len(self.table_col_names))
            for kiter387, viter388 in self.table_col_names.items():
                oprot.writeString(kiter387.encode('utf-8') if sys.version_info[0] == 2 else kiter387)
                oprot.writeListBegin(TType.STRING, len(viter388))
                for iter389 in viter388:
                    oprot.writeString(iter389.encode('utf-8') if sys.version_info[0] == 2 else iter389)
                oprot.writeListEnd()
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.column_format is not None:
            oprot.writeFieldBegin('column_format', TType.BOOL, 5)
            oprot.writeBool(self.column_format)
            oprot.writeFieldEnd()
        if self.pixelRadius is not None:
            oprot.writeFieldBegin('pixelRadius', TType.I32, 6)
            oprot.writeI32(self.pixelRadius)
            oprot.writeFieldEnd()
        if self.nonce is not None:
            oprot.writeFieldBegin('nonce', TType.STRING, 7)
            oprot.writeString(self.nonce.encode('utf-8') if sys.version_info[0] == 2 else self.nonce)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_result_row_for_pixel_args)
get_result_row_for_pixel_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'session', 'UTF8', None, ),  # 1
    (2, TType.I64, 'widget_id', None, None, ),  # 2
    (3, TType.STRUCT, 'pixel', [TPixel, None], None, ),  # 3
    (4, TType.MAP, 'table_col_names', (TType.STRING, 'UTF8', TType.LIST, (TType.STRING, 'UTF8', False), False), None, ),  # 4
    (5, TType.BOOL, 'column_format', None, None, ),  # 5
    (6, TType.I32, 'pixelRadius', None, None, ),  # 6
    (7, TType.STRING, 'nonce', 'UTF8', None, ),  # 7
)


class get_result_row_for_pixel_result(object):
    """
    Attributes:
     - success
     - e

    """


    def __init__(self, success=None, e=None,):
        self.success = success
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = TPixelTableRowResult()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TDBException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_result_row_for_pixel_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_result_row_for_pixel_result)
get_result_row_for_pixel_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [TPixelTableRowResult, None], None, ),  # 0
    (1, TType.STRUCT, 'e', [TDBException, None], None, ),  # 1
)


class create_custom_expression_args(object):
    """
    Attributes:
     - session
     - custom_expression

    """


    def __init__(self, session=None, custom_expression=None,):
        self.session = session
        self.custom_expression = custom_expression

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.session = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.custom_expression = TCustomExpression()
                    self.custom_expression.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('create_custom_expression_args')
        if self.session is not None:
            oprot.writeFieldBegin('session', TType.STRING, 1)
            oprot.writeString(self.session.encode('utf-8') if sys.version_info[0] == 2 else self.session)
            oprot.writeFieldEnd()
        if self.custom_expression is not None:
            oprot.writeFieldBegin('custom_expression', TType.STRUCT, 2)
            self.custom_expression.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(create_custom_expression_args)
create_custom_expression_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'session', 'UTF8', None, ),  # 1
    (2, TType.STRUCT, 'custom_expression', [TCustomExpression, None], None, ),  # 2
)


class create_custom_expression_result(object):
    """
    Attributes:
     - success
     - e

    """


    def __init__(self, success=None, e=None,):
        self.success = success
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TDBException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('create_custom_expression_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(create_custom_expression_result)
create_custom_expression_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'e', [TDBException, None], None, ),  # 1
)


class get_custom_expressions_args(object):
    """
    Attributes:
     - session

    """


    def __init__(self, session=None,):
        self.session = session

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.session = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_custom_expressions_args')
        if self.session is not None:
            oprot.writeFieldBegin('session', TType.STRING, 1)
            oprot.writeString(self.session.encode('utf-8') if sys.version_info[0] == 2 else self.session)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_custom_expressions_args)
get_custom_expressions_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'session', 'UTF8', None, ),  # 1
)


class get_custom_expressions_result(object):
    """
    Attributes:
     - success
     - e

    """


    def __init__(self, success=None, e=None,):
        self.success = success
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype393, _size390) = iprot.readListBegin()
                    for _i394 in range(_size390):
                        _elem395 = TCustomExpression()
                        _elem395.read(iprot)
                        self.success.append(_elem395)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TDBException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_custom_expressions_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter396 in self.success:
                iter396.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_custom_expressions_result)
get_custom_expressions_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT, [TCustomExpression, None], False), None, ),  # 0
    (1, TType.STRUCT, 'e', [TDBException, None], None, ),  # 1
)


class update_custom_expression_args(object):
    """
    Attributes:
     - session
     - id
     - expression_json

    """


    def __init__(self, session=None, id=None, expression_json=None,):
        self.session = session
        self.id = id
        self.expression_json = expression_json

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.session = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.expression_json = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('update_custom_expression_args')
        if self.session is not None:
            oprot.writeFieldBegin('session', TType.STRING, 1)
            oprot.writeString(self.session.encode('utf-8') if sys.version_info[0] == 2 else self.session)
            oprot.writeFieldEnd()
        if self.id is not None:
            oprot.writeFieldBegin('id', TType.I32, 2)
            oprot.writeI32(self.id)
            oprot.writeFieldEnd()
        if self.expression_json is not None:
            oprot.writeFieldBegin('expression_json', TType.STRING, 3)
            oprot.writeString(self.expression_json.encode('utf-8') if sys.version_info[0] == 2 else self.expression_json)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(update_custom_expression_args)
update_custom_expression_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'session', 'UTF8', None, ),  # 1
    (2, TType.I32, 'id', None, None, ),  # 2
    (3, TType.STRING, 'expression_json', 'UTF8', None, ),  # 3
)


class update_custom_expression_result(object):
    """
    Attributes:
     - e

    """


    def __init__(self, e=None,):
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TDBException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('update_custom_expression_result')
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(update_custom_expression_result)
update_custom_expression_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'e', [TDBException, None], None, ),  # 1
)


class delete_custom_expressions_args(object):
    """
    Attributes:
     - session
     - custom_expression_ids
     - do_soft_delete

    """


    def __init__(self, session=None, custom_expression_ids=None, do_soft_delete=None,):
        self.session = session
        self.custom_expression_ids = custom_expression_ids
        self.do_soft_delete = do_soft_delete

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.session = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.custom_expression_ids = []
                    (_etype400, _size397) = iprot.readListBegin()
                    for _i401 in range(_size397):
                        _elem402 = iprot.readI32()
                        self.custom_expression_ids.append(_elem402)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.BOOL:
                    self.do_soft_delete = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('delete_custom_expressions_args')
        if self.session is not None:
            oprot.writeFieldBegin('session', TType.STRING, 1)
            oprot.writeString(self.session.encode('utf-8') if sys.version_info[0] == 2 else self.session)
            oprot.writeFieldEnd()
        if self.custom_expression_ids is not None:
            oprot.writeFieldBegin('custom_expression_ids', TType.LIST, 2)
            oprot.writeListBegin(TType.I32, len(self.custom_expression_ids))
            for iter403 in self.custom_expression_ids:
                oprot.writeI32(iter403)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.do_soft_delete is not None:
            oprot.writeFieldBegin('do_soft_delete', TType.BOOL, 3)
            oprot.writeBool(self.do_soft_delete)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(delete_custom_expressions_args)
delete_custom_expressions_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'session', 'UTF8', None, ),  # 1
    (2, TType.LIST, 'custom_expression_ids', (TType.I32, None, False), None, ),  # 2
    (3, TType.BOOL, 'do_soft_delete', None, None, ),  # 3
)


class delete_custom_expressions_result(object):
    """
    Attributes:
     - e

    """


    def __init__(self, e=None,):
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TDBException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('delete_custom_expressions_result')
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(delete_custom_expressions_result)
delete_custom_expressions_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'e', [TDBException, None], None, ),  # 1
)


class get_dashboard_args(object):
    """
    Attributes:
     - session
     - dashboard_id

    """


    def __init__(self, session=None, dashboard_id=None,):
        self.session = session
        self.dashboard_id = dashboard_id

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.session = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.dashboard_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_dashboard_args')
        if self.session is not None:
            oprot.writeFieldBegin('session', TType.STRING, 1)
            oprot.writeString(self.session.encode('utf-8') if sys.version_info[0] == 2 else self.session)
            oprot.writeFieldEnd()
        if self.dashboard_id is not None:
            oprot.writeFieldBegin('dashboard_id', TType.I32, 2)
            oprot.writeI32(self.dashboard_id)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_dashboard_args)
get_dashboard_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'session', 'UTF8', None, ),  # 1
    (2, TType.I32, 'dashboard_id', None, None, ),  # 2
)


class get_dashboard_result(object):
    """
    Attributes:
     - success
     - e

    """


    def __init__(self, success=None, e=None,):
        self.success = success
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = TDashboard()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TDBException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_dashboard_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_dashboard_result)
get_dashboard_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [TDashboard, None], None, ),  # 0
    (1, TType.STRUCT, 'e', [TDBException, None], None, ),  # 1
)


class get_dashboards_args(object):
    """
    Attributes:
     - session

    """


    def __init__(self, session=None,):
        self.session = session

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.session = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_dashboards_args')
        if self.session is not None:
            oprot.writeFieldBegin('session', TType.STRING, 1)
            oprot.writeString(self.session.encode('utf-8') if sys.version_info[0] == 2 else self.session)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_dashboards_args)
get_dashboards_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'session', 'UTF8', None, ),  # 1
)


class get_dashboards_result(object):
    """
    Attributes:
     - success
     - e

    """


    def __init__(self, success=None, e=None,):
        self.success = success
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype407, _size404) = iprot.readListBegin()
                    for _i408 in range(_size404):
                        _elem409 = TDashboard()
                        _elem409.read(iprot)
                        self.success.append(_elem409)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TDBException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_dashboards_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter410 in self.success:
                iter410.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_dashboards_result)
get_dashboards_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT, [TDashboard, None], False), None, ),  # 0
    (1, TType.STRUCT, 'e', [TDBException, None], None, ),  # 1
)


class create_dashboard_args(object):
    """
    Attributes:
     - session
     - dashboard_name
     - dashboard_state
     - image_hash
     - dashboard_metadata

    """


    def __init__(self, session=None, dashboard_name=None, dashboard_state=None, image_hash=None, dashboard_metadata=None,):
        self.session = session
        self.dashboard_name = dashboard_name
        self.dashboard_state = dashboard_state
        self.image_hash = image_hash
        self.dashboard_metadata = dashboard_metadata

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.session = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.dashboard_name = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.dashboard_state = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.image_hash = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRING:
                    self.dashboard_metadata = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('create_dashboard_args')
        if self.session is not None:
            oprot.writeFieldBegin('session', TType.STRING, 1)
            oprot.writeString(self.session.encode('utf-8') if sys.version_info[0] == 2 else self.session)
            oprot.writeFieldEnd()
        if self.dashboard_name is not None:
            oprot.writeFieldBegin('dashboard_name', TType.STRING, 2)
            oprot.writeString(self.dashboard_name.encode('utf-8') if sys.version_info[0] == 2 else self.dashboard_name)
            oprot.writeFieldEnd()
        if self.dashboard_state is not None:
            oprot.writeFieldBegin('dashboard_state', TType.STRING, 3)
            oprot.writeString(self.dashboard_state.encode('utf-8') if sys.version_info[0] == 2 else self.dashboard_state)
            oprot.writeFieldEnd()
        if self.image_hash is not None:
            oprot.writeFieldBegin('image_hash', TType.STRING, 4)
            oprot.writeString(self.image_hash.encode('utf-8') if sys.version_info[0] == 2 else self.image_hash)
            oprot.writeFieldEnd()
        if self.dashboard_metadata is not None:
            oprot.writeFieldBegin('dashboard_metadata', TType.STRING, 5)
            oprot.writeString(self.dashboard_metadata.encode('utf-8') if sys.version_info[0] == 2 else self.dashboard_metadata)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(create_dashboard_args)
create_dashboard_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'session', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'dashboard_name', 'UTF8', None, ),  # 2
    (3, TType.STRING, 'dashboard_state', 'UTF8', None, ),  # 3
    (4, TType.STRING, 'image_hash', 'UTF8', None, ),  # 4
    (5, TType.STRING, 'dashboard_metadata', 'UTF8', None, ),  # 5
)


class create_dashboard_result(object):
    """
    Attributes:
     - success
     - e

    """


    def __init__(self, success=None, e=None,):
        self.success = success
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TDBException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('create_dashboard_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(create_dashboard_result)
create_dashboard_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'e', [TDBException, None], None, ),  # 1
)


class replace_dashboard_args(object):
    """
    Attributes:
     - session
     - dashboard_id
     - dashboard_name
     - dashboard_owner
     - dashboard_state
     - image_hash
     - dashboard_metadata

    """


    def __init__(self, session=None, dashboard_id=None, dashboard_name=None, dashboard_owner=None, dashboard_state=None, image_hash=None, dashboard_metadata=None,):
        self.session = session
        self.dashboard_id = dashboard_id
        self.dashboard_name = dashboard_name
        self.dashboard_owner = dashboard_owner
        self.dashboard_state = dashboard_state
        self.image_hash = image_hash
        self.dashboard_metadata = dashboard_metadata

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.session = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.dashboard_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.dashboard_name = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.dashboard_owner = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRING:
                    self.dashboard_state = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRING:
                    self.image_hash = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.STRING:
                    self.dashboard_metadata = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('replace_dashboard_args')
        if self.session is not None:
            oprot.writeFieldBegin('session', TType.STRING, 1)
            oprot.writeString(self.session.encode('utf-8') if sys.version_info[0] == 2 else self.session)
            oprot.writeFieldEnd()
        if self.dashboard_id is not None:
            oprot.writeFieldBegin('dashboard_id', TType.I32, 2)
            oprot.writeI32(self.dashboard_id)
            oprot.writeFieldEnd()
        if self.dashboard_name is not None:
            oprot.writeFieldBegin('dashboard_name', TType.STRING, 3)
            oprot.writeString(self.dashboard_name.encode('utf-8') if sys.version_info[0] == 2 else self.dashboard_name)
            oprot.writeFieldEnd()
        if self.dashboard_owner is not None:
            oprot.writeFieldBegin('dashboard_owner', TType.STRING, 4)
            oprot.writeString(self.dashboard_owner.encode('utf-8') if sys.version_info[0] == 2 else self.dashboard_owner)
            oprot.writeFieldEnd()
        if self.dashboard_state is not None:
            oprot.writeFieldBegin('dashboard_state', TType.STRING, 5)
            oprot.writeString(self.dashboard_state.encode('utf-8') if sys.version_info[0] == 2 else self.dashboard_state)
            oprot.writeFieldEnd()
        if self.image_hash is not None:
            oprot.writeFieldBegin('image_hash', TType.STRING, 6)
            oprot.writeString(self.image_hash.encode('utf-8') if sys.version_info[0] == 2 else self.image_hash)
            oprot.writeFieldEnd()
        if self.dashboard_metadata is not None:
            oprot.writeFieldBegin('dashboard_metadata', TType.STRING, 7)
            oprot.writeString(self.dashboard_metadata.encode('utf-8') if sys.version_info[0] == 2 else self.dashboard_metadata)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(replace_dashboard_args)
replace_dashboard_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'session', 'UTF8', None, ),  # 1
    (2, TType.I32, 'dashboard_id', None, None, ),  # 2
    (3, TType.STRING, 'dashboard_name', 'UTF8', None, ),  # 3
    (4, TType.STRING, 'dashboard_owner', 'UTF8', None, ),  # 4
    (5, TType.STRING, 'dashboard_state', 'UTF8', None, ),  # 5
    (6, TType.STRING, 'image_hash', 'UTF8', None, ),  # 6
    (7, TType.STRING, 'dashboard_metadata', 'UTF8', None, ),  # 7
)


class replace_dashboard_result(object):
    """
    Attributes:
     - e

    """


    def __init__(self, e=None,):
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TDBException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('replace_dashboard_result')
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(replace_dashboard_result)
replace_dashboard_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'e', [TDBException, None], None, ),  # 1
)


class delete_dashboard_args(object):
    """
    Attributes:
     - session
     - dashboard_id

    """


    def __init__(self, session=None, dashboard_id=None,):
        self.session = session
        self.dashboard_id = dashboard_id

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.session = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.dashboard_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('delete_dashboard_args')
        if self.session is not None:
            oprot.writeFieldBegin('session', TType.STRING, 1)
            oprot.writeString(self.session.encode('utf-8') if sys.version_info[0] == 2 else self.session)
            oprot.writeFieldEnd()
        if self.dashboard_id is not None:
            oprot.writeFieldBegin('dashboard_id', TType.I32, 2)
            oprot.writeI32(self.dashboard_id)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(delete_dashboard_args)
delete_dashboard_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'session', 'UTF8', None, ),  # 1
    (2, TType.I32, 'dashboard_id', None, None, ),  # 2
)


class delete_dashboard_result(object):
    """
    Attributes:
     - e

    """


    def __init__(self, e=None,):
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TDBException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('delete_dashboard_result')
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(delete_dashboard_result)
delete_dashboard_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'e', [TDBException, None], None, ),  # 1
)


class share_dashboards_args(object):
    """
    Attributes:
     - session
     - dashboard_ids
     - groups
     - permissions

    """


    def __init__(self, session=None, dashboard_ids=None, groups=None, permissions=None,):
        self.session = session
        self.dashboard_ids = dashboard_ids
        self.groups = groups
        self.permissions = permissions

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.session = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.dashboard_ids = []
                    (_etype414, _size411) = iprot.readListBegin()
                    for _i415 in range(_size411):
                        _elem416 = iprot.readI32()
                        self.dashboard_ids.append(_elem416)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.groups = []
                    (_etype420, _size417) = iprot.readListBegin()
                    for _i421 in range(_size417):
                        _elem422 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.groups.append(_elem422)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.permissions = TDashboardPermissions()
                    self.permissions.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('share_dashboards_args')
        if self.session is not None:
            oprot.writeFieldBegin('session', TType.STRING, 1)
            oprot.writeString(self.session.encode('utf-8') if sys.version_info[0] == 2 else self.session)
            oprot.writeFieldEnd()
        if self.dashboard_ids is not None:
            oprot.writeFieldBegin('dashboard_ids', TType.LIST, 2)
            oprot.writeListBegin(TType.I32, len(self.dashboard_ids))
            for iter423 in self.dashboard_ids:
                oprot.writeI32(iter423)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.groups is not None:
            oprot.writeFieldBegin('groups', TType.LIST, 3)
            oprot.writeListBegin(TType.STRING, len(self.groups))
            for iter424 in self.groups:
                oprot.writeString(iter424.encode('utf-8') if sys.version_info[0] == 2 else iter424)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.permissions is not None:
            oprot.writeFieldBegin('permissions', TType.STRUCT, 4)
            self.permissions.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(share_dashboards_args)
share_dashboards_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'session', 'UTF8', None, ),  # 1
    (2, TType.LIST, 'dashboard_ids', (TType.I32, None, False), None, ),  # 2
    (3, TType.LIST, 'groups', (TType.STRING, 'UTF8', False), None, ),  # 3
    (4, TType.STRUCT, 'permissions', [TDashboardPermissions, None], None, ),  # 4
)


class share_dashboards_result(object):
    """
    Attributes:
     - e

    """


    def __init__(self, e=None,):
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TDBException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('share_dashboards_result')
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(share_dashboards_result)
share_dashboards_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'e', [TDBException, None], None, ),  # 1
)


class delete_dashboards_args(object):
    """
    Attributes:
     - session
     - dashboard_ids

    """


    def __init__(self, session=None, dashboard_ids=None,):
        self.session = session
        self.dashboard_ids = dashboard_ids

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.session = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.dashboard_ids = []
                    (_etype428, _size425) = iprot.readListBegin()
                    for _i429 in range(_size425):
                        _elem430 = iprot.readI32()
                        self.dashboard_ids.append(_elem430)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('delete_dashboards_args')
        if self.session is not None:
            oprot.writeFieldBegin('session', TType.STRING, 1)
            oprot.writeString(self.session.encode('utf-8') if sys.version_info[0] == 2 else self.session)
            oprot.writeFieldEnd()
        if self.dashboard_ids is not None:
            oprot.writeFieldBegin('dashboard_ids', TType.LIST, 2)
            oprot.writeListBegin(TType.I32, len(self.dashboard_ids))
            for iter431 in self.dashboard_ids:
                oprot.writeI32(iter431)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(delete_dashboards_args)
delete_dashboards_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'session', 'UTF8', None, ),  # 1
    (2, TType.LIST, 'dashboard_ids', (TType.I32, None, False), None, ),  # 2
)


class delete_dashboards_result(object):
    """
    Attributes:
     - e

    """


    def __init__(self, e=None,):
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TDBException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('delete_dashboards_result')
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(delete_dashboards_result)
delete_dashboards_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'e', [TDBException, None], None, ),  # 1
)


class share_dashboard_args(object):
    """
    Attributes:
     - session
     - dashboard_id
     - groups
     - objects
     - permissions
     - grant_role

    """


    def __init__(self, session=None, dashboard_id=None, groups=None, objects=None, permissions=None, grant_role=False,):
        self.session = session
        self.dashboard_id = dashboard_id
        self.groups = groups
        self.objects = objects
        self.permissions = permissions
        self.grant_role = grant_role

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.session = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.dashboard_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.groups = []
                    (_etype435, _size432) = iprot.readListBegin()
                    for _i436 in range(_size432):
                        _elem437 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.groups.append(_elem437)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.LIST:
                    self.objects = []
                    (_etype441, _size438) = iprot.readListBegin()
                    for _i442 in range(_size438):
                        _elem443 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.objects.append(_elem443)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRUCT:
                    self.permissions = TDashboardPermissions()
                    self.permissions.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.BOOL:
                    self.grant_role = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('share_dashboard_args')
        if self.session is not None:
            oprot.writeFieldBegin('session', TType.STRING, 1)
            oprot.writeString(self.session.encode('utf-8') if sys.version_info[0] == 2 else self.session)
            oprot.writeFieldEnd()
        if self.dashboard_id is not None:
            oprot.writeFieldBegin('dashboard_id', TType.I32, 2)
            oprot.writeI32(self.dashboard_id)
            oprot.writeFieldEnd()
        if self.groups is not None:
            oprot.writeFieldBegin('groups', TType.LIST, 3)
            oprot.writeListBegin(TType.STRING, len(self.groups))
            for iter444 in self.groups:
                oprot.writeString(iter444.encode('utf-8') if sys.version_info[0] == 2 else iter444)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.objects is not None:
            oprot.writeFieldBegin('objects', TType.LIST, 4)
            oprot.writeListBegin(TType.STRING, len(self.objects))
            for iter445 in self.objects:
                oprot.writeString(iter445.encode('utf-8') if sys.version_info[0] == 2 else iter445)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.permissions is not None:
            oprot.writeFieldBegin('permissions', TType.STRUCT, 5)
            self.permissions.write(oprot)
            oprot.writeFieldEnd()
        if self.grant_role is not None:
            oprot.writeFieldBegin('grant_role', TType.BOOL, 6)
            oprot.writeBool(self.grant_role)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(share_dashboard_args)
share_dashboard_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'session', 'UTF8', None, ),  # 1
    (2, TType.I32, 'dashboard_id', None, None, ),  # 2
    (3, TType.LIST, 'groups', (TType.STRING, 'UTF8', False), None, ),  # 3
    (4, TType.LIST, 'objects', (TType.STRING, 'UTF8', False), None, ),  # 4
    (5, TType.STRUCT, 'permissions', [TDashboardPermissions, None], None, ),  # 5
    (6, TType.BOOL, 'grant_role', None, False, ),  # 6
)


class share_dashboard_result(object):
    """
    Attributes:
     - e

    """


    def __init__(self, e=None,):
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TDBException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('share_dashboard_result')
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(share_dashboard_result)
share_dashboard_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'e', [TDBException, None], None, ),  # 1
)


class unshare_dashboard_args(object):
    """
    Attributes:
     - session
     - dashboard_id
     - groups
     - objects
     - permissions

    """


    def __init__(self, session=None, dashboard_id=None, groups=None, objects=None, permissions=None,):
        self.session = session
        self.dashboard_id = dashboard_id
        self.groups = groups
        self.objects = objects
        self.permissions = permissions

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.session = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.dashboard_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.groups = []
                    (_etype449, _size446) = iprot.readListBegin()
                    for _i450 in range(_size446):
                        _elem451 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.groups.append(_elem451)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.LIST:
                    self.objects = []
                    (_etype455, _size452) = iprot.readListBegin()
                    for _i456 in range(_size452):
                        _elem457 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.objects.append(_elem457)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRUCT:
                    self.permissions = TDashboardPermissions()
                    self.permissions.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('unshare_dashboard_args')
        if self.session is not None:
            oprot.writeFieldBegin('session', TType.STRING, 1)
            oprot.writeString(self.session.encode('utf-8') if sys.version_info[0] == 2 else self.session)
            oprot.writeFieldEnd()
        if self.dashboard_id is not None:
            oprot.writeFieldBegin('dashboard_id', TType.I32, 2)
            oprot.writeI32(self.dashboard_id)
            oprot.writeFieldEnd()
        if self.groups is not None:
            oprot.writeFieldBegin('groups', TType.LIST, 3)
            oprot.writeListBegin(TType.STRING, len(self.groups))
            for iter458 in self.groups:
                oprot.writeString(iter458.encode('utf-8') if sys.version_info[0] == 2 else iter458)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.objects is not None:
            oprot.writeFieldBegin('objects', TType.LIST, 4)
            oprot.writeListBegin(TType.STRING, len(self.objects))
            for iter459 in self.objects:
                oprot.writeString(iter459.encode('utf-8') if sys.version_info[0] == 2 else iter459)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.permissions is not None:
            oprot.writeFieldBegin('permissions', TType.STRUCT, 5)
            self.permissions.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(unshare_dashboard_args)
unshare_dashboard_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'session', 'UTF8', None, ),  # 1
    (2, TType.I32, 'dashboard_id', None, None, ),  # 2
    (3, TType.LIST, 'groups', (TType.STRING, 'UTF8', False), None, ),  # 3
    (4, TType.LIST, 'objects', (TType.STRING, 'UTF8', False), None, ),  # 4
    (5, TType.STRUCT, 'permissions', [TDashboardPermissions, None], None, ),  # 5
)


class unshare_dashboard_result(object):
    """
    Attributes:
     - e

    """


    def __init__(self, e=None,):
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TDBException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('unshare_dashboard_result')
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(unshare_dashboard_result)
unshare_dashboard_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'e', [TDBException, None], None, ),  # 1
)


class unshare_dashboards_args(object):
    """
    Attributes:
     - session
     - dashboard_ids
     - groups
     - permissions

    """


    def __init__(self, session=None, dashboard_ids=None, groups=None, permissions=None,):
        self.session = session
        self.dashboard_ids = dashboard_ids
        self.groups = groups
        self.permissions = permissions

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.session = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.dashboard_ids = []
                    (_etype463, _size460) = iprot.readListBegin()
                    for _i464 in range(_size460):
                        _elem465 = iprot.readI32()
                        self.dashboard_ids.append(_elem465)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.groups = []
                    (_etype469, _size466) = iprot.readListBegin()
                    for _i470 in range(_size466):
                        _elem471 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.groups.append(_elem471)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.permissions = TDashboardPermissions()
                    self.permissions.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('unshare_dashboards_args')
        if self.session is not None:
            oprot.writeFieldBegin('session', TType.STRING, 1)
            oprot.writeString(self.session.encode('utf-8') if sys.version_info[0] == 2 else self.session)
            oprot.writeFieldEnd()
        if self.dashboard_ids is not None:
            oprot.writeFieldBegin('dashboard_ids', TType.LIST, 2)
            oprot.writeListBegin(TType.I32, len(self.dashboard_ids))
            for iter472 in self.dashboard_ids:
                oprot.writeI32(iter472)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.groups is not None:
            oprot.writeFieldBegin('groups', TType.LIST, 3)
            oprot.writeListBegin(TType.STRING, len(self.groups))
            for iter473 in self.groups:
                oprot.writeString(iter473.encode('utf-8') if sys.version_info[0] == 2 else iter473)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.permissions is not None:
            oprot.writeFieldBegin('permissions', TType.STRUCT, 4)
            self.permissions.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(unshare_dashboards_args)
unshare_dashboards_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'session', 'UTF8', None, ),  # 1
    (2, TType.LIST, 'dashboard_ids', (TType.I32, None, False), None, ),  # 2
    (3, TType.LIST, 'groups', (TType.STRING, 'UTF8', False), None, ),  # 3
    (4, TType.STRUCT, 'permissions', [TDashboardPermissions, None], None, ),  # 4
)


class unshare_dashboards_result(object):
    """
    Attributes:
     - e

    """


    def __init__(self, e=None,):
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TDBException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('unshare_dashboards_result')
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(unshare_dashboards_result)
unshare_dashboards_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'e', [TDBException, None], None, ),  # 1
)


class get_dashboard_grantees_args(object):
    """
    Attributes:
     - session
     - dashboard_id

    """


    def __init__(self, session=None, dashboard_id=None,):
        self.session = session
        self.dashboard_id = dashboard_id

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.session = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.dashboard_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_dashboard_grantees_args')
        if self.session is not None:
            oprot.writeFieldBegin('session', TType.STRING, 1)
            oprot.writeString(self.session.encode('utf-8') if sys.version_info[0] == 2 else self.session)
            oprot.writeFieldEnd()
        if self.dashboard_id is not None:
            oprot.writeFieldBegin('dashboard_id', TType.I32, 2)
            oprot.writeI32(self.dashboard_id)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_dashboard_grantees_args)
get_dashboard_grantees_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'session', 'UTF8', None, ),  # 1
    (2, TType.I32, 'dashboard_id', None, None, ),  # 2
)


class get_dashboard_grantees_result(object):
    """
    Attributes:
     - success
     - e

    """


    def __init__(self, success=None, e=None,):
        self.success = success
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype477, _size474) = iprot.readListBegin()
                    for _i478 in range(_size474):
                        _elem479 = TDashboardGrantees()
                        _elem479.read(iprot)
                        self.success.append(_elem479)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TDBException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_dashboard_grantees_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter480 in self.success:
                iter480.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_dashboard_grantees_result)
get_dashboard_grantees_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT, [TDashboardGrantees, None], False), None, ),  # 0
    (1, TType.STRUCT, 'e', [TDBException, None], None, ),  # 1
)


class get_link_view_args(object):
    """
    Attributes:
     - session
     - link

    """


    def __init__(self, session=None, link=None,):
        self.session = session
        self.link = link

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.session = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.link = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_link_view_args')
        if self.session is not None:
            oprot.writeFieldBegin('session', TType.STRING, 1)
            oprot.writeString(self.session.encode('utf-8') if sys.version_info[0] == 2 else self.session)
            oprot.writeFieldEnd()
        if self.link is not None:
            oprot.writeFieldBegin('link', TType.STRING, 2)
            oprot.writeString(self.link.encode('utf-8') if sys.version_info[0] == 2 else self.link)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_link_view_args)
get_link_view_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'session', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'link', 'UTF8', None, ),  # 2
)


class get_link_view_result(object):
    """
    Attributes:
     - success
     - e

    """


    def __init__(self, success=None, e=None,):
        self.success = success
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = TFrontendView()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TDBException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_link_view_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_link_view_result)
get_link_view_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [TFrontendView, None], None, ),  # 0
    (1, TType.STRUCT, 'e', [TDBException, None], None, ),  # 1
)


class create_link_args(object):
    """
    Attributes:
     - session
     - view_state
     - view_metadata

    """


    def __init__(self, session=None, view_state=None, view_metadata=None,):
        self.session = session
        self.view_state = view_state
        self.view_metadata = view_metadata

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.session = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.view_state = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.view_metadata = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('create_link_args')
        if self.session is not None:
            oprot.writeFieldBegin('session', TType.STRING, 1)
            oprot.writeString(self.session.encode('utf-8') if sys.version_info[0] == 2 else self.session)
            oprot.writeFieldEnd()
        if self.view_state is not None:
            oprot.writeFieldBegin('view_state', TType.STRING, 2)
            oprot.writeString(self.view_state.encode('utf-8') if sys.version_info[0] == 2 else self.view_state)
            oprot.writeFieldEnd()
        if self.view_metadata is not None:
            oprot.writeFieldBegin('view_metadata', TType.STRING, 3)
            oprot.writeString(self.view_metadata.encode('utf-8') if sys.version_info[0] == 2 else self.view_metadata)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(create_link_args)
create_link_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'session', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'view_state', 'UTF8', None, ),  # 2
    (3, TType.STRING, 'view_metadata', 'UTF8', None, ),  # 3
)


class create_link_result(object):
    """
    Attributes:
     - success
     - e

    """


    def __init__(self, success=None, e=None,):
        self.success = success
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRING:
                    self.success = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TDBException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('create_link_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRING, 0)
            oprot.writeString(self.success.encode('utf-8') if sys.version_info[0] == 2 else self.success)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(create_link_result)
create_link_result.thrift_spec = (
    (0, TType.STRING, 'success', 'UTF8', None, ),  # 0
    (1, TType.STRUCT, 'e', [TDBException, None], None, ),  # 1
)


class load_table_binary_args(object):
    """
    Attributes:
     - session
     - table_name
     - rows
     - column_names

    """


    def __init__(self, session=None, table_name=None, rows=None, column_names=[
    ],):
        self.session = session
        self.table_name = table_name
        self.rows = rows
        if column_names is self.thrift_spec[4][4]:
            column_names = [
            ]
        self.column_names = column_names

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.session = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.table_name = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.rows = []
                    (_etype484, _size481) = iprot.readListBegin()
                    for _i485 in range(_size481):
                        _elem486 = TRow()
                        _elem486.read(iprot)
                        self.rows.append(_elem486)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.LIST:
                    self.column_names = []
                    (_etype490, _size487) = iprot.readListBegin()
                    for _i491 in range(_size487):
                        _elem492 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.column_names.append(_elem492)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('load_table_binary_args')
        if self.session is not None:
            oprot.writeFieldBegin('session', TType.STRING, 1)
            oprot.writeString(self.session.encode('utf-8') if sys.version_info[0] == 2 else self.session)
            oprot.writeFieldEnd()
        if self.table_name is not None:
            oprot.writeFieldBegin('table_name', TType.STRING, 2)
            oprot.writeString(self.table_name.encode('utf-8') if sys.version_info[0] == 2 else self.table_name)
            oprot.writeFieldEnd()
        if self.rows is not None:
            oprot.writeFieldBegin('rows', TType.LIST, 3)
            oprot.writeListBegin(TType.STRUCT, len(self.rows))
            for iter493 in self.rows:
                iter493.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.column_names is not None:
            oprot.writeFieldBegin('column_names', TType.LIST, 4)
            oprot.writeListBegin(TType.STRING, len(self.column_names))
            for iter494 in self.column_names:
                oprot.writeString(iter494.encode('utf-8') if sys.version_info[0] == 2 else iter494)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(load_table_binary_args)
load_table_binary_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'session', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'table_name', 'UTF8', None, ),  # 2
    (3, TType.LIST, 'rows', (TType.STRUCT, [TRow, None], False), None, ),  # 3
    (4, TType.LIST, 'column_names', (TType.STRING, 'UTF8', False), [
    ], ),  # 4
)


class load_table_binary_result(object):
    """
    Attributes:
     - e

    """


    def __init__(self, e=None,):
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TDBException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('load_table_binary_result')
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(load_table_binary_result)
load_table_binary_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'e', [TDBException, None], None, ),  # 1
)


class load_table_binary_columnar_args(object):
    """
    Attributes:
     - session
     - table_name
     - cols
     - column_names

    """


    def __init__(self, session=None, table_name=None, cols=None, column_names=[
    ],):
        self.session = session
        self.table_name = table_name
        self.cols = cols
        if column_names is self.thrift_spec[4][4]:
            column_names = [
            ]
        self.column_names = column_names

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.session = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.table_name = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.cols = []
                    (_etype498, _size495) = iprot.readListBegin()
                    for _i499 in range(_size495):
                        _elem500 = TColumn()
                        _elem500.read(iprot)
                        self.cols.append(_elem500)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.LIST:
                    self.column_names = []
                    (_etype504, _size501) = iprot.readListBegin()
                    for _i505 in range(_size501):
                        _elem506 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.column_names.append(_elem506)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('load_table_binary_columnar_args')
        if self.session is not None:
            oprot.writeFieldBegin('session', TType.STRING, 1)
            oprot.writeString(self.session.encode('utf-8') if sys.version_info[0] == 2 else self.session)
            oprot.writeFieldEnd()
        if self.table_name is not None:
            oprot.writeFieldBegin('table_name', TType.STRING, 2)
            oprot.writeString(self.table_name.encode('utf-8') if sys.version_info[0] == 2 else self.table_name)
            oprot.writeFieldEnd()
        if self.cols is not None:
            oprot.writeFieldBegin('cols', TType.LIST, 3)
            oprot.writeListBegin(TType.STRUCT, len(self.cols))
            for iter507 in self.cols:
                iter507.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.column_names is not None:
            oprot.writeFieldBegin('column_names', TType.LIST, 4)
            oprot.writeListBegin(TType.STRING, len(self.column_names))
            for iter508 in self.column_names:
                oprot.writeString(iter508.encode('utf-8') if sys.version_info[0] == 2 else iter508)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(load_table_binary_columnar_args)
load_table_binary_columnar_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'session', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'table_name', 'UTF8', None, ),  # 2
    (3, TType.LIST, 'cols', (TType.STRUCT, [TColumn, None], False), None, ),  # 3
    (4, TType.LIST, 'column_names', (TType.STRING, 'UTF8', False), [
    ], ),  # 4
)


class load_table_binary_columnar_result(object):
    """
    Attributes:
     - e

    """


    def __init__(self, e=None,):
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TDBException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('load_table_binary_columnar_result')
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(load_table_binary_columnar_result)
load_table_binary_columnar_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'e', [TDBException, None], None, ),  # 1
)


class load_table_binary_columnar_polys_args(object):
    """
    Attributes:
     - session
     - table_name
     - cols
     - column_names
     - assign_render_groups

    """


    def __init__(self, session=None, table_name=None, cols=None, column_names=[
    ], assign_render_groups=True,):
        self.session = session
        self.table_name = table_name
        self.cols = cols
        if column_names is self.thrift_spec[4][4]:
            column_names = [
            ]
        self.column_names = column_names
        self.assign_render_groups = assign_render_groups

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.session = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.table_name = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.cols = []
                    (_etype512, _size509) = iprot.readListBegin()
                    for _i513 in range(_size509):
                        _elem514 = TColumn()
                        _elem514.read(iprot)
                        self.cols.append(_elem514)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.LIST:
                    self.column_names = []
                    (_etype518, _size515) = iprot.readListBegin()
                    for _i519 in range(_size515):
                        _elem520 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.column_names.append(_elem520)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.BOOL:
                    self.assign_render_groups = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('load_table_binary_columnar_polys_args')
        if self.session is not None:
            oprot.writeFieldBegin('session', TType.STRING, 1)
            oprot.writeString(self.session.encode('utf-8') if sys.version_info[0] == 2 else self.session)
            oprot.writeFieldEnd()
        if self.table_name is not None:
            oprot.writeFieldBegin('table_name', TType.STRING, 2)
            oprot.writeString(self.table_name.encode('utf-8') if sys.version_info[0] == 2 else self.table_name)
            oprot.writeFieldEnd()
        if self.cols is not None:
            oprot.writeFieldBegin('cols', TType.LIST, 3)
            oprot.writeListBegin(TType.STRUCT, len(self.cols))
            for iter521 in self.cols:
                iter521.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.column_names is not None:
            oprot.writeFieldBegin('column_names', TType.LIST, 4)
            oprot.writeListBegin(TType.STRING, len(self.column_names))
            for iter522 in self.column_names:
                oprot.writeString(iter522.encode('utf-8') if sys.version_info[0] == 2 else iter522)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.assign_render_groups is not None:
            oprot.writeFieldBegin('assign_render_groups', TType.BOOL, 5)
            oprot.writeBool(self.assign_render_groups)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(load_table_binary_columnar_polys_args)
load_table_binary_columnar_polys_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'session', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'table_name', 'UTF8', None, ),  # 2
    (3, TType.LIST, 'cols', (TType.STRUCT, [TColumn, None], False), None, ),  # 3
    (4, TType.LIST, 'column_names', (TType.STRING, 'UTF8', False), [
    ], ),  # 4
    (5, TType.BOOL, 'assign_render_groups', None, True, ),  # 5
)


class load_table_binary_columnar_polys_result(object):
    """
    Attributes:
     - e

    """


    def __init__(self, e=None,):
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TDBException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('load_table_binary_columnar_polys_result')
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(load_table_binary_columnar_polys_result)
load_table_binary_columnar_polys_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'e', [TDBException, None], None, ),  # 1
)


class load_table_binary_arrow_args(object):
    """
    Attributes:
     - session
     - table_name
     - arrow_stream
     - use_column_names

    """


    def __init__(self, session=None, table_name=None, arrow_stream=None, use_column_names=False,):
        self.session = session
        self.table_name = table_name
        self.arrow_stream = arrow_stream
        self.use_column_names = use_column_names

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.session = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.table_name = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.arrow_stream = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.BOOL:
                    self.use_column_names = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('load_table_binary_arrow_args')
        if self.session is not None:
            oprot.writeFieldBegin('session', TType.STRING, 1)
            oprot.writeString(self.session.encode('utf-8') if sys.version_info[0] == 2 else self.session)
            oprot.writeFieldEnd()
        if self.table_name is not None:
            oprot.writeFieldBegin('table_name', TType.STRING, 2)
            oprot.writeString(self.table_name.encode('utf-8') if sys.version_info[0] == 2 else self.table_name)
            oprot.writeFieldEnd()
        if self.arrow_stream is not None:
            oprot.writeFieldBegin('arrow_stream', TType.STRING, 3)
            oprot.writeBinary(self.arrow_stream)
            oprot.writeFieldEnd()
        if self.use_column_names is not None:
            oprot.writeFieldBegin('use_column_names', TType.BOOL, 4)
            oprot.writeBool(self.use_column_names)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(load_table_binary_arrow_args)
load_table_binary_arrow_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'session', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'table_name', 'UTF8', None, ),  # 2
    (3, TType.STRING, 'arrow_stream', 'BINARY', None, ),  # 3
    (4, TType.BOOL, 'use_column_names', None, False, ),  # 4
)


class load_table_binary_arrow_result(object):
    """
    Attributes:
     - e

    """


    def __init__(self, e=None,):
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TDBException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('load_table_binary_arrow_result')
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(load_table_binary_arrow_result)
load_table_binary_arrow_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'e', [TDBException, None], None, ),  # 1
)


class load_table_args(object):
    """
    Attributes:
     - session
     - table_name
     - rows
     - column_names

    """


    def __init__(self, session=None, table_name=None, rows=None, column_names=[
    ],):
        self.session = session
        self.table_name = table_name
        self.rows = rows
        if column_names is self.thrift_spec[4][4]:
            column_names = [
            ]
        self.column_names = column_names

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.session = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.table_name = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.rows = []
                    (_etype526, _size523) = iprot.readListBegin()
                    for _i527 in range(_size523):
                        _elem528 = TStringRow()
                        _elem528.read(iprot)
                        self.rows.append(_elem528)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.LIST:
                    self.column_names = []
                    (_etype532, _size529) = iprot.readListBegin()
                    for _i533 in range(_size529):
                        _elem534 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.column_names.append(_elem534)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('load_table_args')
        if self.session is not None:
            oprot.writeFieldBegin('session', TType.STRING, 1)
            oprot.writeString(self.session.encode('utf-8') if sys.version_info[0] == 2 else self.session)
            oprot.writeFieldEnd()
        if self.table_name is not None:
            oprot.writeFieldBegin('table_name', TType.STRING, 2)
            oprot.writeString(self.table_name.encode('utf-8') if sys.version_info[0] == 2 else self.table_name)
            oprot.writeFieldEnd()
        if self.rows is not None:
            oprot.writeFieldBegin('rows', TType.LIST, 3)
            oprot.writeListBegin(TType.STRUCT, len(self.rows))
            for iter535 in self.rows:
                iter535.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.column_names is not None:
            oprot.writeFieldBegin('column_names', TType.LIST, 4)
            oprot.writeListBegin(TType.STRING, len(self.column_names))
            for iter536 in self.column_names:
                oprot.writeString(iter536.encode('utf-8') if sys.version_info[0] == 2 else iter536)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(load_table_args)
load_table_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'session', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'table_name', 'UTF8', None, ),  # 2
    (3, TType.LIST, 'rows', (TType.STRUCT, [TStringRow, None], False), None, ),  # 3
    (4, TType.LIST, 'column_names', (TType.STRING, 'UTF8', False), [
    ], ),  # 4
)


class load_table_result(object):
    """
    Attributes:
     - e

    """


    def __init__(self, e=None,):
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TDBException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('load_table_result')
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(load_table_result)
load_table_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'e', [TDBException, None], None, ),  # 1
)


class detect_column_types_args(object):
    """
    Attributes:
     - session
     - file_name
     - copy_params

    """


    def __init__(self, session=None, file_name=None, copy_params=None,):
        self.session = session
        self.file_name = file_name
        self.copy_params = copy_params

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.session = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.file_name = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.copy_params = TCopyParams()
                    self.copy_params.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('detect_column_types_args')
        if self.session is not None:
            oprot.writeFieldBegin('session', TType.STRING, 1)
            oprot.writeString(self.session.encode('utf-8') if sys.version_info[0] == 2 else self.session)
            oprot.writeFieldEnd()
        if self.file_name is not None:
            oprot.writeFieldBegin('file_name', TType.STRING, 2)
            oprot.writeString(self.file_name.encode('utf-8') if sys.version_info[0] == 2 else self.file_name)
            oprot.writeFieldEnd()
        if self.copy_params is not None:
            oprot.writeFieldBegin('copy_params', TType.STRUCT, 3)
            self.copy_params.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(detect_column_types_args)
detect_column_types_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'session', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'file_name', 'UTF8', None, ),  # 2
    (3, TType.STRUCT, 'copy_params', [TCopyParams, None], None, ),  # 3
)


class detect_column_types_result(object):
    """
    Attributes:
     - success
     - e

    """


    def __init__(self, success=None, e=None,):
        self.success = success
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = TDetectResult()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TDBException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('detect_column_types_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(detect_column_types_result)
detect_column_types_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [TDetectResult, None], None, ),  # 0
    (1, TType.STRUCT, 'e', [TDBException, None], None, ),  # 1
)


class create_table_args(object):
    """
    Attributes:
     - session
     - table_name
     - row_desc
     - create_params

    """


    def __init__(self, session=None, table_name=None, row_desc=None, create_params=None,):
        self.session = session
        self.table_name = table_name
        self.row_desc = row_desc
        self.create_params = create_params

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.session = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.table_name = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.row_desc = []
                    (_etype540, _size537) = iprot.readListBegin()
                    for _i541 in range(_size537):
                        _elem542 = TColumnType()
                        _elem542.read(iprot)
                        self.row_desc.append(_elem542)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.create_params = TCreateParams()
                    self.create_params.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('create_table_args')
        if self.session is not None:
            oprot.writeFieldBegin('session', TType.STRING, 1)
            oprot.writeString(self.session.encode('utf-8') if sys.version_info[0] == 2 else self.session)
            oprot.writeFieldEnd()
        if self.table_name is not None:
            oprot.writeFieldBegin('table_name', TType.STRING, 2)
            oprot.writeString(self.table_name.encode('utf-8') if sys.version_info[0] == 2 else self.table_name)
            oprot.writeFieldEnd()
        if self.row_desc is not None:
            oprot.writeFieldBegin('row_desc', TType.LIST, 3)
            oprot.writeListBegin(TType.STRUCT, len(self.row_desc))
            for iter543 in self.row_desc:
                iter543.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.create_params is not None:
            oprot.writeFieldBegin('create_params', TType.STRUCT, 4)
            self.create_params.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(create_table_args)
create_table_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'session', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'table_name', 'UTF8', None, ),  # 2
    (3, TType.LIST, 'row_desc', (TType.STRUCT, [TColumnType, None], False), None, ),  # 3
    (4, TType.STRUCT, 'create_params', [TCreateParams, None], None, ),  # 4
)


class create_table_result(object):
    """
    Attributes:
     - e

    """


    def __init__(self, e=None,):
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TDBException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('create_table_result')
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(create_table_result)
create_table_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'e', [TDBException, None], None, ),  # 1
)


class import_table_args(object):
    """
    Attributes:
     - session
     - table_name
     - file_name
     - copy_params

    """


    def __init__(self, session=None, table_name=None, file_name=None, copy_params=None,):
        self.session = session
        self.table_name = table_name
        self.file_name = file_name
        self.copy_params = copy_params

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.session = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.table_name = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.file_name = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.copy_params = TCopyParams()
                    self.copy_params.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('import_table_args')
        if self.session is not None:
            oprot.writeFieldBegin('session', TType.STRING, 1)
            oprot.writeString(self.session.encode('utf-8') if sys.version_info[0] == 2 else self.session)
            oprot.writeFieldEnd()
        if self.table_name is not None:
            oprot.writeFieldBegin('table_name', TType.STRING, 2)
            oprot.writeString(self.table_name.encode('utf-8') if sys.version_info[0] == 2 else self.table_name)
            oprot.writeFieldEnd()
        if self.file_name is not None:
            oprot.writeFieldBegin('file_name', TType.STRING, 3)
            oprot.writeString(self.file_name.encode('utf-8') if sys.version_info[0] == 2 else self.file_name)
            oprot.writeFieldEnd()
        if self.copy_params is not None:
            oprot.writeFieldBegin('copy_params', TType.STRUCT, 4)
            self.copy_params.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(import_table_args)
import_table_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'session', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'table_name', 'UTF8', None, ),  # 2
    (3, TType.STRING, 'file_name', 'UTF8', None, ),  # 3
    (4, TType.STRUCT, 'copy_params', [TCopyParams, None], None, ),  # 4
)


class import_table_result(object):
    """
    Attributes:
     - e

    """


    def __init__(self, e=None,):
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TDBException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('import_table_result')
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(import_table_result)
import_table_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'e', [TDBException, None], None, ),  # 1
)


class import_geo_table_args(object):
    """
    Attributes:
     - session
     - table_name
     - file_name
     - copy_params
     - row_desc
     - create_params

    """


    def __init__(self, session=None, table_name=None, file_name=None, copy_params=None, row_desc=None, create_params=None,):
        self.session = session
        self.table_name = table_name
        self.file_name = file_name
        self.copy_params = copy_params
        self.row_desc = row_desc
        self.create_params = create_params

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.session = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.table_name = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.file_name = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.copy_params = TCopyParams()
                    self.copy_params.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.LIST:
                    self.row_desc = []
                    (_etype547, _size544) = iprot.readListBegin()
                    for _i548 in range(_size544):
                        _elem549 = TColumnType()
                        _elem549.read(iprot)
                        self.row_desc.append(_elem549)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRUCT:
                    self.create_params = TCreateParams()
                    self.create_params.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('import_geo_table_args')
        if self.session is not None:
            oprot.writeFieldBegin('session', TType.STRING, 1)
            oprot.writeString(self.session.encode('utf-8') if sys.version_info[0] == 2 else self.session)
            oprot.writeFieldEnd()
        if self.table_name is not None:
            oprot.writeFieldBegin('table_name', TType.STRING, 2)
            oprot.writeString(self.table_name.encode('utf-8') if sys.version_info[0] == 2 else self.table_name)
            oprot.writeFieldEnd()
        if self.file_name is not None:
            oprot.writeFieldBegin('file_name', TType.STRING, 3)
            oprot.writeString(self.file_name.encode('utf-8') if sys.version_info[0] == 2 else self.file_name)
            oprot.writeFieldEnd()
        if self.copy_params is not None:
            oprot.writeFieldBegin('copy_params', TType.STRUCT, 4)
            self.copy_params.write(oprot)
            oprot.writeFieldEnd()
        if self.row_desc is not None:
            oprot.writeFieldBegin('row_desc', TType.LIST, 5)
            oprot.writeListBegin(TType.STRUCT, len(self.row_desc))
            for iter550 in self.row_desc:
                iter550.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.create_params is not None:
            oprot.writeFieldBegin('create_params', TType.STRUCT, 6)
            self.create_params.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(import_geo_table_args)
import_geo_table_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'session', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'table_name', 'UTF8', None, ),  # 2
    (3, TType.STRING, 'file_name', 'UTF8', None, ),  # 3
    (4, TType.STRUCT, 'copy_params', [TCopyParams, None], None, ),  # 4
    (5, TType.LIST, 'row_desc', (TType.STRUCT, [TColumnType, None], False), None, ),  # 5
    (6, TType.STRUCT, 'create_params', [TCreateParams, None], None, ),  # 6
)


class import_geo_table_result(object):
    """
    Attributes:
     - e

    """


    def __init__(self, e=None,):
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TDBException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('import_geo_table_result')
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(import_geo_table_result)
import_geo_table_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'e', [TDBException, None], None, ),  # 1
)


class import_table_status_args(object):
    """
    Attributes:
     - session
     - import_id

    """


    def __init__(self, session=None, import_id=None,):
        self.session = session
        self.import_id = import_id

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.session = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.import_id = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('import_table_status_args')
        if self.session is not None:
            oprot.writeFieldBegin('session', TType.STRING, 1)
            oprot.writeString(self.session.encode('utf-8') if sys.version_info[0] == 2 else self.session)
            oprot.writeFieldEnd()
        if self.import_id is not None:
            oprot.writeFieldBegin('import_id', TType.STRING, 2)
            oprot.writeString(self.import_id.encode('utf-8') if sys.version_info[0] == 2 else self.import_id)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(import_table_status_args)
import_table_status_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'session', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'import_id', 'UTF8', None, ),  # 2
)


class import_table_status_result(object):
    """
    Attributes:
     - success
     - e

    """


    def __init__(self, success=None, e=None,):
        self.success = success
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = TImportStatus()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TDBException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('import_table_status_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(import_table_status_result)
import_table_status_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [TImportStatus, None], None, ),  # 0
    (1, TType.STRUCT, 'e', [TDBException, None], None, ),  # 1
)


class get_first_geo_file_in_archive_args(object):
    """
    Attributes:
     - session
     - archive_path
     - copy_params

    """


    def __init__(self, session=None, archive_path=None, copy_params=None,):
        self.session = session
        self.archive_path = archive_path
        self.copy_params = copy_params

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.session = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.archive_path = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.copy_params = TCopyParams()
                    self.copy_params.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_first_geo_file_in_archive_args')
        if self.session is not None:
            oprot.writeFieldBegin('session', TType.STRING, 1)
            oprot.writeString(self.session.encode('utf-8') if sys.version_info[0] == 2 else self.session)
            oprot.writeFieldEnd()
        if self.archive_path is not None:
            oprot.writeFieldBegin('archive_path', TType.STRING, 2)
            oprot.writeString(self.archive_path.encode('utf-8') if sys.version_info[0] == 2 else self.archive_path)
            oprot.writeFieldEnd()
        if self.copy_params is not None:
            oprot.writeFieldBegin('copy_params', TType.STRUCT, 3)
            self.copy_params.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_first_geo_file_in_archive_args)
get_first_geo_file_in_archive_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'session', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'archive_path', 'UTF8', None, ),  # 2
    (3, TType.STRUCT, 'copy_params', [TCopyParams, None], None, ),  # 3
)


class get_first_geo_file_in_archive_result(object):
    """
    Attributes:
     - success
     - e

    """


    def __init__(self, success=None, e=None,):
        self.success = success
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRING:
                    self.success = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TDBException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_first_geo_file_in_archive_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRING, 0)
            oprot.writeString(self.success.encode('utf-8') if sys.version_info[0] == 2 else self.success)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_first_geo_file_in_archive_result)
get_first_geo_file_in_archive_result.thrift_spec = (
    (0, TType.STRING, 'success', 'UTF8', None, ),  # 0
    (1, TType.STRUCT, 'e', [TDBException, None], None, ),  # 1
)


class get_all_files_in_archive_args(object):
    """
    Attributes:
     - session
     - archive_path
     - copy_params

    """


    def __init__(self, session=None, archive_path=None, copy_params=None,):
        self.session = session
        self.archive_path = archive_path
        self.copy_params = copy_params

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.session = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.archive_path = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.copy_params = TCopyParams()
                    self.copy_params.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_all_files_in_archive_args')
        if self.session is not None:
            oprot.writeFieldBegin('session', TType.STRING, 1)
            oprot.writeString(self.session.encode('utf-8') if sys.version_info[0] == 2 else self.session)
            oprot.writeFieldEnd()
        if self.archive_path is not None:
            oprot.writeFieldBegin('archive_path', TType.STRING, 2)
            oprot.writeString(self.archive_path.encode('utf-8') if sys.version_info[0] == 2 else self.archive_path)
            oprot.writeFieldEnd()
        if self.copy_params is not None:
            oprot.writeFieldBegin('copy_params', TType.STRUCT, 3)
            self.copy_params.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_all_files_in_archive_args)
get_all_files_in_archive_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'session', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'archive_path', 'UTF8', None, ),  # 2
    (3, TType.STRUCT, 'copy_params', [TCopyParams, None], None, ),  # 3
)


class get_all_files_in_archive_result(object):
    """
    Attributes:
     - success
     - e

    """


    def __init__(self, success=None, e=None,):
        self.success = success
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype554, _size551) = iprot.readListBegin()
                    for _i555 in range(_size551):
                        _elem556 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.success.append(_elem556)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TDBException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_all_files_in_archive_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRING, len(self.success))
            for iter557 in self.success:
                oprot.writeString(iter557.encode('utf-8') if sys.version_info[0] == 2 else iter557)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_all_files_in_archive_result)
get_all_files_in_archive_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRING, 'UTF8', False), None, ),  # 0
    (1, TType.STRUCT, 'e', [TDBException, None], None, ),  # 1
)


class get_layers_in_geo_file_args(object):
    """
    Attributes:
     - session
     - file_name
     - copy_params

    """


    def __init__(self, session=None, file_name=None, copy_params=None,):
        self.session = session
        self.file_name = file_name
        self.copy_params = copy_params

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.session = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.file_name = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.copy_params = TCopyParams()
                    self.copy_params.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_layers_in_geo_file_args')
        if self.session is not None:
            oprot.writeFieldBegin('session', TType.STRING, 1)
            oprot.writeString(self.session.encode('utf-8') if sys.version_info[0] == 2 else self.session)
            oprot.writeFieldEnd()
        if self.file_name is not None:
            oprot.writeFieldBegin('file_name', TType.STRING, 2)
            oprot.writeString(self.file_name.encode('utf-8') if sys.version_info[0] == 2 else self.file_name)
            oprot.writeFieldEnd()
        if self.copy_params is not None:
            oprot.writeFieldBegin('copy_params', TType.STRUCT, 3)
            self.copy_params.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_layers_in_geo_file_args)
get_layers_in_geo_file_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'session', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'file_name', 'UTF8', None, ),  # 2
    (3, TType.STRUCT, 'copy_params', [TCopyParams, None], None, ),  # 3
)


class get_layers_in_geo_file_result(object):
    """
    Attributes:
     - success
     - e

    """


    def __init__(self, success=None, e=None,):
        self.success = success
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype561, _size558) = iprot.readListBegin()
                    for _i562 in range(_size558):
                        _elem563 = TGeoFileLayerInfo()
                        _elem563.read(iprot)
                        self.success.append(_elem563)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TDBException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_layers_in_geo_file_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter564 in self.success:
                iter564.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_layers_in_geo_file_result)
get_layers_in_geo_file_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT, [TGeoFileLayerInfo, None], False), None, ),  # 0
    (1, TType.STRUCT, 'e', [TDBException, None], None, ),  # 1
)


class query_get_outer_fragment_count_args(object):
    """
    Attributes:
     - session
     - query

    """


    def __init__(self, session=None, query=None,):
        self.session = session
        self.query = query

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.session = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.query = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('query_get_outer_fragment_count_args')
        if self.session is not None:
            oprot.writeFieldBegin('session', TType.STRING, 1)
            oprot.writeString(self.session.encode('utf-8') if sys.version_info[0] == 2 else self.session)
            oprot.writeFieldEnd()
        if self.query is not None:
            oprot.writeFieldBegin('query', TType.STRING, 2)
            oprot.writeString(self.query.encode('utf-8') if sys.version_info[0] == 2 else self.query)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(query_get_outer_fragment_count_args)
query_get_outer_fragment_count_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'session', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'query', 'UTF8', None, ),  # 2
)


class query_get_outer_fragment_count_result(object):
    """
    Attributes:
     - success
     - e

    """


    def __init__(self, success=None, e=None,):
        self.success = success
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I64:
                    self.success = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TDBException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('query_get_outer_fragment_count_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I64, 0)
            oprot.writeI64(self.success)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(query_get_outer_fragment_count_result)
query_get_outer_fragment_count_result.thrift_spec = (
    (0, TType.I64, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'e', [TDBException, None], None, ),  # 1
)


class check_table_consistency_args(object):
    """
    Attributes:
     - session
     - table_id

    """


    def __init__(self, session=None, table_id=None,):
        self.session = session
        self.table_id = table_id

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.session = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.table_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('check_table_consistency_args')
        if self.session is not None:
            oprot.writeFieldBegin('session', TType.STRING, 1)
            oprot.writeString(self.session.encode('utf-8') if sys.version_info[0] == 2 else self.session)
            oprot.writeFieldEnd()
        if self.table_id is not None:
            oprot.writeFieldBegin('table_id', TType.I32, 2)
            oprot.writeI32(self.table_id)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(check_table_consistency_args)
check_table_consistency_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'session', 'UTF8', None, ),  # 1
    (2, TType.I32, 'table_id', None, None, ),  # 2
)


class check_table_consistency_result(object):
    """
    Attributes:
     - success
     - e

    """


    def __init__(self, success=None, e=None,):
        self.success = success
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = TTableMeta()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TDBException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('check_table_consistency_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(check_table_consistency_result)
check_table_consistency_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [TTableMeta, None], None, ),  # 0
    (1, TType.STRUCT, 'e', [TDBException, None], None, ),  # 1
)


class start_query_args(object):
    """
    Attributes:
     - leaf_session
     - parent_session
     - query_ra
     - start_time_str
     - just_explain
     - outer_fragment_indices

    """


    def __init__(self, leaf_session=None, parent_session=None, query_ra=None, start_time_str=None, just_explain=None, outer_fragment_indices=None,):
        self.leaf_session = leaf_session
        self.parent_session = parent_session
        self.query_ra = query_ra
        self.start_time_str = start_time_str
        self.just_explain = just_explain
        self.outer_fragment_indices = outer_fragment_indices

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.leaf_session = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.parent_session = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.query_ra = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.start_time_str = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.BOOL:
                    self.just_explain = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.LIST:
                    self.outer_fragment_indices = []
                    (_etype568, _size565) = iprot.readListBegin()
                    for _i569 in range(_size565):
                        _elem570 = iprot.readI64()
                        self.outer_fragment_indices.append(_elem570)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('start_query_args')
        if self.leaf_session is not None:
            oprot.writeFieldBegin('leaf_session', TType.STRING, 1)
            oprot.writeString(self.leaf_session.encode('utf-8') if sys.version_info[0] == 2 else self.leaf_session)
            oprot.writeFieldEnd()
        if self.parent_session is not None:
            oprot.writeFieldBegin('parent_session', TType.STRING, 2)
            oprot.writeString(self.parent_session.encode('utf-8') if sys.version_info[0] == 2 else self.parent_session)
            oprot.writeFieldEnd()
        if self.query_ra is not None:
            oprot.writeFieldBegin('query_ra', TType.STRING, 3)
            oprot.writeString(self.query_ra.encode('utf-8') if sys.version_info[0] == 2 else self.query_ra)
            oprot.writeFieldEnd()
        if self.start_time_str is not None:
            oprot.writeFieldBegin('start_time_str', TType.STRING, 4)
            oprot.writeString(self.start_time_str.encode('utf-8') if sys.version_info[0] == 2 else self.start_time_str)
            oprot.writeFieldEnd()
        if self.just_explain is not None:
            oprot.writeFieldBegin('just_explain', TType.BOOL, 5)
            oprot.writeBool(self.just_explain)
            oprot.writeFieldEnd()
        if self.outer_fragment_indices is not None:
            oprot.writeFieldBegin('outer_fragment_indices', TType.LIST, 6)
            oprot.writeListBegin(TType.I64, len(self.outer_fragment_indices))
            for iter571 in self.outer_fragment_indices:
                oprot.writeI64(iter571)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(start_query_args)
start_query_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'leaf_session', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'parent_session', 'UTF8', None, ),  # 2
    (3, TType.STRING, 'query_ra', 'UTF8', None, ),  # 3
    (4, TType.STRING, 'start_time_str', 'UTF8', None, ),  # 4
    (5, TType.BOOL, 'just_explain', None, None, ),  # 5
    (6, TType.LIST, 'outer_fragment_indices', (TType.I64, None, False), None, ),  # 6
)


class start_query_result(object):
    """
    Attributes:
     - success
     - e

    """


    def __init__(self, success=None, e=None,):
        self.success = success
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = TPendingQuery()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TDBException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('start_query_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(start_query_result)
start_query_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [TPendingQuery, None], None, ),  # 0
    (1, TType.STRUCT, 'e', [TDBException, None], None, ),  # 1
)


class execute_query_step_args(object):
    """
    Attributes:
     - pending_query
     - subquery_id
     - start_time_str

    """


    def __init__(self, pending_query=None, subquery_id=None, start_time_str=None,):
        self.pending_query = pending_query
        self.subquery_id = subquery_id
        self.start_time_str = start_time_str

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.pending_query = TPendingQuery()
                    self.pending_query.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.subquery_id = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.start_time_str = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('execute_query_step_args')
        if self.pending_query is not None:
            oprot.writeFieldBegin('pending_query', TType.STRUCT, 1)
            self.pending_query.write(oprot)
            oprot.writeFieldEnd()
        if self.subquery_id is not None:
            oprot.writeFieldBegin('subquery_id', TType.I64, 2)
            oprot.writeI64(self.subquery_id)
            oprot.writeFieldEnd()
        if self.start_time_str is not None:
            oprot.writeFieldBegin('start_time_str', TType.STRING, 3)
            oprot.writeString(self.start_time_str.encode('utf-8') if sys.version_info[0] == 2 else self.start_time_str)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(execute_query_step_args)
execute_query_step_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'pending_query', [TPendingQuery, None], None, ),  # 1
    (2, TType.I64, 'subquery_id', None, None, ),  # 2
    (3, TType.STRING, 'start_time_str', 'UTF8', None, ),  # 3
)


class execute_query_step_result(object):
    """
    Attributes:
     - success
     - e

    """


    def __init__(self, success=None, e=None,):
        self.success = success
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = TStepResult()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TDBException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('execute_query_step_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(execute_query_step_result)
execute_query_step_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [TStepResult, None], None, ),  # 0
    (1, TType.STRUCT, 'e', [TDBException, None], None, ),  # 1
)


class broadcast_serialized_rows_args(object):
    """
    Attributes:
     - serialized_rows
     - row_desc
     - query_id
     - subquery_id
     - is_final_subquery_result

    """


    def __init__(self, serialized_rows=None, row_desc=None, query_id=None, subquery_id=None, is_final_subquery_result=None,):
        self.serialized_rows = serialized_rows
        self.row_desc = row_desc
        self.query_id = query_id
        self.subquery_id = subquery_id
        self.is_final_subquery_result = is_final_subquery_result

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.serialized_rows = heavydb.serialized_result_set.ttypes.TSerializedRows()
                    self.serialized_rows.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.row_desc = []
                    (_etype575, _size572) = iprot.readListBegin()
                    for _i576 in range(_size572):
                        _elem577 = TColumnType()
                        _elem577.read(iprot)
                        self.row_desc.append(_elem577)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I64:
                    self.query_id = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I64:
                    self.subquery_id = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.BOOL:
                    self.is_final_subquery_result = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('broadcast_serialized_rows_args')
        if self.serialized_rows is not None:
            oprot.writeFieldBegin('serialized_rows', TType.STRUCT, 1)
            self.serialized_rows.write(oprot)
            oprot.writeFieldEnd()
        if self.row_desc is not None:
            oprot.writeFieldBegin('row_desc', TType.LIST, 2)
            oprot.writeListBegin(TType.STRUCT, len(self.row_desc))
            for iter578 in self.row_desc:
                iter578.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.query_id is not None:
            oprot.writeFieldBegin('query_id', TType.I64, 3)
            oprot.writeI64(self.query_id)
            oprot.writeFieldEnd()
        if self.subquery_id is not None:
            oprot.writeFieldBegin('subquery_id', TType.I64, 4)
            oprot.writeI64(self.subquery_id)
            oprot.writeFieldEnd()
        if self.is_final_subquery_result is not None:
            oprot.writeFieldBegin('is_final_subquery_result', TType.BOOL, 5)
            oprot.writeBool(self.is_final_subquery_result)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(broadcast_serialized_rows_args)
broadcast_serialized_rows_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'serialized_rows', [heavydb.serialized_result_set.ttypes.TSerializedRows, None], None,),  # 1
    (2, TType.LIST, 'row_desc', (TType.STRUCT, [TColumnType, None], False), None, ),  # 2
    (3, TType.I64, 'query_id', None, None, ),  # 3
    (4, TType.I64, 'subquery_id', None, None, ),  # 4
    (5, TType.BOOL, 'is_final_subquery_result', None, None, ),  # 5
)


class broadcast_serialized_rows_result(object):
    """
    Attributes:
     - e

    """


    def __init__(self, e=None,):
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TDBException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('broadcast_serialized_rows_result')
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(broadcast_serialized_rows_result)
broadcast_serialized_rows_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'e', [TDBException, None], None, ),  # 1
)


class start_render_query_args(object):
    """
    Attributes:
     - session
     - widget_id
     - node_idx
     - vega_json

    """


    def __init__(self, session=None, widget_id=None, node_idx=None, vega_json=None,):
        self.session = session
        self.widget_id = widget_id
        self.node_idx = node_idx
        self.vega_json = vega_json

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.session = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.widget_id = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I16:
                    self.node_idx = iprot.readI16()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.vega_json = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('start_render_query_args')
        if self.session is not None:
            oprot.writeFieldBegin('session', TType.STRING, 1)
            oprot.writeString(self.session.encode('utf-8') if sys.version_info[0] == 2 else self.session)
            oprot.writeFieldEnd()
        if self.widget_id is not None:
            oprot.writeFieldBegin('widget_id', TType.I64, 2)
            oprot.writeI64(self.widget_id)
            oprot.writeFieldEnd()
        if self.node_idx is not None:
            oprot.writeFieldBegin('node_idx', TType.I16, 3)
            oprot.writeI16(self.node_idx)
            oprot.writeFieldEnd()
        if self.vega_json is not None:
            oprot.writeFieldBegin('vega_json', TType.STRING, 4)
            oprot.writeString(self.vega_json.encode('utf-8') if sys.version_info[0] == 2 else self.vega_json)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(start_render_query_args)
start_render_query_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'session', 'UTF8', None, ),  # 1
    (2, TType.I64, 'widget_id', None, None, ),  # 2
    (3, TType.I16, 'node_idx', None, None, ),  # 3
    (4, TType.STRING, 'vega_json', 'UTF8', None, ),  # 4
)


class start_render_query_result(object):
    """
    Attributes:
     - success
     - e

    """


    def __init__(self, success=None, e=None,):
        self.success = success
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = TPendingRenderQuery()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TDBException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('start_render_query_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(start_render_query_result)
start_render_query_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [TPendingRenderQuery, None], None, ),  # 0
    (1, TType.STRUCT, 'e', [TDBException, None], None, ),  # 1
)


class execute_next_render_step_args(object):
    """
    Attributes:
     - pending_render
     - merged_data

    """


    def __init__(self, pending_render=None, merged_data=None,):
        self.pending_render = pending_render
        self.merged_data = merged_data

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.pending_render = TPendingRenderQuery()
                    self.pending_render.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.MAP:
                    self.merged_data = {}
                    (_ktype580, _vtype581, _size579) = iprot.readMapBegin()
                    for _i583 in range(_size579):
                        _key584 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        _val585 = {}
                        (_ktype587, _vtype588, _size586) = iprot.readMapBegin()
                        for _i590 in range(_size586):
                            _key591 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                            _val592 = {}
                            (_ktype594, _vtype595, _size593) = iprot.readMapBegin()
                            for _i597 in range(_size593):
                                _key598 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                                _val599 = {}
                                (_ktype601, _vtype602, _size600) = iprot.readMapBegin()
                                for _i604 in range(_size600):
                                    _key605 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                                    _val606 = []
                                    (_etype610, _size607) = iprot.readListBegin()
                                    for _i611 in range(_size607):
                                        _elem612 = TRenderDatum()
                                        _elem612.read(iprot)
                                        _val606.append(_elem612)
                                    iprot.readListEnd()
                                    _val599[_key605] = _val606
                                iprot.readMapEnd()
                                _val592[_key598] = _val599
                            iprot.readMapEnd()
                            _val585[_key591] = _val592
                        iprot.readMapEnd()
                        self.merged_data[_key584] = _val585
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('execute_next_render_step_args')
        if self.pending_render is not None:
            oprot.writeFieldBegin('pending_render', TType.STRUCT, 1)
            self.pending_render.write(oprot)
            oprot.writeFieldEnd()
        if self.merged_data is not None:
            oprot.writeFieldBegin('merged_data', TType.MAP, 2)
            oprot.writeMapBegin(TType.STRING, TType.MAP, len(self.merged_data))
            for kiter613, viter614 in self.merged_data.items():
                oprot.writeString(kiter613.encode('utf-8') if sys.version_info[0] == 2 else kiter613)
                oprot.writeMapBegin(TType.STRING, TType.MAP, len(viter614))
                for kiter615, viter616 in viter614.items():
                    oprot.writeString(kiter615.encode('utf-8') if sys.version_info[0] == 2 else kiter615)
                    oprot.writeMapBegin(TType.STRING, TType.MAP, len(viter616))
                    for kiter617, viter618 in viter616.items():
                        oprot.writeString(kiter617.encode('utf-8') if sys.version_info[0] == 2 else kiter617)
                        oprot.writeMapBegin(TType.STRING, TType.LIST, len(viter618))
                        for kiter619, viter620 in viter618.items():
                            oprot.writeString(kiter619.encode('utf-8') if sys.version_info[0] == 2 else kiter619)
                            oprot.writeListBegin(TType.STRUCT, len(viter620))
                            for iter621 in viter620:
                                iter621.write(oprot)
                            oprot.writeListEnd()
                        oprot.writeMapEnd()
                    oprot.writeMapEnd()
                oprot.writeMapEnd()
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(execute_next_render_step_args)
execute_next_render_step_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'pending_render', [TPendingRenderQuery, None], None, ),  # 1
    (2, TType.MAP, 'merged_data', (TType.STRING, 'UTF8', TType.MAP, (TType.STRING, 'UTF8', TType.MAP, (TType.STRING, 'UTF8', TType.MAP, (TType.STRING, 'UTF8', TType.LIST, (TType.STRUCT, [TRenderDatum, None], False), False), False), False), False), None, ),  # 2
)


class execute_next_render_step_result(object):
    """
    Attributes:
     - success
     - e

    """


    def __init__(self, success=None, e=None,):
        self.success = success
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = TRenderStepResult()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TDBException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('execute_next_render_step_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(execute_next_render_step_result)
execute_next_render_step_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [TRenderStepResult, None], None, ),  # 0
    (1, TType.STRUCT, 'e', [TDBException, None], None, ),  # 1
)


class insert_data_args(object):
    """
    Attributes:
     - session
     - insert_data

    """


    def __init__(self, session=None, insert_data=None,):
        self.session = session
        self.insert_data = insert_data

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.session = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.insert_data = TInsertData()
                    self.insert_data.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('insert_data_args')
        if self.session is not None:
            oprot.writeFieldBegin('session', TType.STRING, 1)
            oprot.writeString(self.session.encode('utf-8') if sys.version_info[0] == 2 else self.session)
            oprot.writeFieldEnd()
        if self.insert_data is not None:
            oprot.writeFieldBegin('insert_data', TType.STRUCT, 2)
            self.insert_data.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(insert_data_args)
insert_data_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'session', 'UTF8', None, ),  # 1
    (2, TType.STRUCT, 'insert_data', [TInsertData, None], None, ),  # 2
)


class insert_data_result(object):
    """
    Attributes:
     - e

    """


    def __init__(self, e=None,):
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TDBException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('insert_data_result')
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(insert_data_result)
insert_data_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'e', [TDBException, None], None, ),  # 1
)


class insert_chunks_args(object):
    """
    Attributes:
     - session
     - insert_chunks

    """


    def __init__(self, session=None, insert_chunks=None,):
        self.session = session
        self.insert_chunks = insert_chunks

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.session = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.insert_chunks = TInsertChunks()
                    self.insert_chunks.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('insert_chunks_args')
        if self.session is not None:
            oprot.writeFieldBegin('session', TType.STRING, 1)
            oprot.writeString(self.session.encode('utf-8') if sys.version_info[0] == 2 else self.session)
            oprot.writeFieldEnd()
        if self.insert_chunks is not None:
            oprot.writeFieldBegin('insert_chunks', TType.STRUCT, 2)
            self.insert_chunks.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(insert_chunks_args)
insert_chunks_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'session', 'UTF8', None, ),  # 1
    (2, TType.STRUCT, 'insert_chunks', [TInsertChunks, None], None, ),  # 2
)


class insert_chunks_result(object):
    """
    Attributes:
     - e

    """


    def __init__(self, e=None,):
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TDBException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('insert_chunks_result')
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(insert_chunks_result)
insert_chunks_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'e', [TDBException, None], None, ),  # 1
)


class checkpoint_args(object):
    """
    Attributes:
     - session
     - table_id

    """


    def __init__(self, session=None, table_id=None,):
        self.session = session
        self.table_id = table_id

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.session = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.table_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('checkpoint_args')
        if self.session is not None:
            oprot.writeFieldBegin('session', TType.STRING, 1)
            oprot.writeString(self.session.encode('utf-8') if sys.version_info[0] == 2 else self.session)
            oprot.writeFieldEnd()
        if self.table_id is not None:
            oprot.writeFieldBegin('table_id', TType.I32, 2)
            oprot.writeI32(self.table_id)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(checkpoint_args)
checkpoint_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'session', 'UTF8', None, ),  # 1
    (2, TType.I32, 'table_id', None, None, ),  # 2
)


class checkpoint_result(object):
    """
    Attributes:
     - e

    """


    def __init__(self, e=None,):
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TDBException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('checkpoint_result')
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(checkpoint_result)
checkpoint_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'e', [TDBException, None], None, ),  # 1
)


class get_roles_args(object):
    """
    Attributes:
     - session

    """


    def __init__(self, session=None,):
        self.session = session

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.session = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_roles_args')
        if self.session is not None:
            oprot.writeFieldBegin('session', TType.STRING, 1)
            oprot.writeString(self.session.encode('utf-8') if sys.version_info[0] == 2 else self.session)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_roles_args)
get_roles_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'session', 'UTF8', None, ),  # 1
)


class get_roles_result(object):
    """
    Attributes:
     - success
     - e

    """


    def __init__(self, success=None, e=None,):
        self.success = success
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype625, _size622) = iprot.readListBegin()
                    for _i626 in range(_size622):
                        _elem627 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.success.append(_elem627)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TDBException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_roles_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRING, len(self.success))
            for iter628 in self.success:
                oprot.writeString(iter628.encode('utf-8') if sys.version_info[0] == 2 else iter628)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_roles_result)
get_roles_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRING, 'UTF8', False), None, ),  # 0
    (1, TType.STRUCT, 'e', [TDBException, None], None, ),  # 1
)


class get_db_objects_for_grantee_args(object):
    """
    Attributes:
     - session
     - roleName

    """


    def __init__(self, session=None, roleName=None,):
        self.session = session
        self.roleName = roleName

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.session = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.roleName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_db_objects_for_grantee_args')
        if self.session is not None:
            oprot.writeFieldBegin('session', TType.STRING, 1)
            oprot.writeString(self.session.encode('utf-8') if sys.version_info[0] == 2 else self.session)
            oprot.writeFieldEnd()
        if self.roleName is not None:
            oprot.writeFieldBegin('roleName', TType.STRING, 2)
            oprot.writeString(self.roleName.encode('utf-8') if sys.version_info[0] == 2 else self.roleName)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_db_objects_for_grantee_args)
get_db_objects_for_grantee_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'session', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'roleName', 'UTF8', None, ),  # 2
)


class get_db_objects_for_grantee_result(object):
    """
    Attributes:
     - success
     - e

    """


    def __init__(self, success=None, e=None,):
        self.success = success
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype632, _size629) = iprot.readListBegin()
                    for _i633 in range(_size629):
                        _elem634 = TDBObject()
                        _elem634.read(iprot)
                        self.success.append(_elem634)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TDBException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_db_objects_for_grantee_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter635 in self.success:
                iter635.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_db_objects_for_grantee_result)
get_db_objects_for_grantee_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT, [TDBObject, None], False), None, ),  # 0
    (1, TType.STRUCT, 'e', [TDBException, None], None, ),  # 1
)


class get_db_object_privs_args(object):
    """
    Attributes:
     - session
     - objectName
     - type

    """


    def __init__(self, session=None, objectName=None, type=None,):
        self.session = session
        self.objectName = objectName
        self.type = type

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.session = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.objectName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.type = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_db_object_privs_args')
        if self.session is not None:
            oprot.writeFieldBegin('session', TType.STRING, 1)
            oprot.writeString(self.session.encode('utf-8') if sys.version_info[0] == 2 else self.session)
            oprot.writeFieldEnd()
        if self.objectName is not None:
            oprot.writeFieldBegin('objectName', TType.STRING, 2)
            oprot.writeString(self.objectName.encode('utf-8') if sys.version_info[0] == 2 else self.objectName)
            oprot.writeFieldEnd()
        if self.type is not None:
            oprot.writeFieldBegin('type', TType.I32, 3)
            oprot.writeI32(self.type)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_db_object_privs_args)
get_db_object_privs_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'session', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'objectName', 'UTF8', None, ),  # 2
    (3, TType.I32, 'type', None, None, ),  # 3
)


class get_db_object_privs_result(object):
    """
    Attributes:
     - success
     - e

    """


    def __init__(self, success=None, e=None,):
        self.success = success
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype639, _size636) = iprot.readListBegin()
                    for _i640 in range(_size636):
                        _elem641 = TDBObject()
                        _elem641.read(iprot)
                        self.success.append(_elem641)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TDBException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_db_object_privs_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter642 in self.success:
                iter642.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_db_object_privs_result)
get_db_object_privs_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT, [TDBObject, None], False), None, ),  # 0
    (1, TType.STRUCT, 'e', [TDBException, None], None, ),  # 1
)


class get_all_roles_for_user_args(object):
    """
    Attributes:
     - session
     - userName

    """


    def __init__(self, session=None, userName=None,):
        self.session = session
        self.userName = userName

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.session = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.userName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_all_roles_for_user_args')
        if self.session is not None:
            oprot.writeFieldBegin('session', TType.STRING, 1)
            oprot.writeString(self.session.encode('utf-8') if sys.version_info[0] == 2 else self.session)
            oprot.writeFieldEnd()
        if self.userName is not None:
            oprot.writeFieldBegin('userName', TType.STRING, 2)
            oprot.writeString(self.userName.encode('utf-8') if sys.version_info[0] == 2 else self.userName)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_all_roles_for_user_args)
get_all_roles_for_user_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'session', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'userName', 'UTF8', None, ),  # 2
)


class get_all_roles_for_user_result(object):
    """
    Attributes:
     - success
     - e

    """


    def __init__(self, success=None, e=None,):
        self.success = success
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype646, _size643) = iprot.readListBegin()
                    for _i647 in range(_size643):
                        _elem648 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.success.append(_elem648)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TDBException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_all_roles_for_user_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRING, len(self.success))
            for iter649 in self.success:
                oprot.writeString(iter649.encode('utf-8') if sys.version_info[0] == 2 else iter649)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_all_roles_for_user_result)
get_all_roles_for_user_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRING, 'UTF8', False), None, ),  # 0
    (1, TType.STRUCT, 'e', [TDBException, None], None, ),  # 1
)


class get_all_effective_roles_for_user_args(object):
    """
    Attributes:
     - session
     - userName

    """


    def __init__(self, session=None, userName=None,):
        self.session = session
        self.userName = userName

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.session = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.userName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_all_effective_roles_for_user_args')
        if self.session is not None:
            oprot.writeFieldBegin('session', TType.STRING, 1)
            oprot.writeString(self.session.encode('utf-8') if sys.version_info[0] == 2 else self.session)
            oprot.writeFieldEnd()
        if self.userName is not None:
            oprot.writeFieldBegin('userName', TType.STRING, 2)
            oprot.writeString(self.userName.encode('utf-8') if sys.version_info[0] == 2 else self.userName)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_all_effective_roles_for_user_args)
get_all_effective_roles_for_user_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'session', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'userName', 'UTF8', None, ),  # 2
)


class get_all_effective_roles_for_user_result(object):
    """
    Attributes:
     - success
     - e

    """


    def __init__(self, success=None, e=None,):
        self.success = success
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype653, _size650) = iprot.readListBegin()
                    for _i654 in range(_size650):
                        _elem655 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.success.append(_elem655)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TDBException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_all_effective_roles_for_user_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRING, len(self.success))
            for iter656 in self.success:
                oprot.writeString(iter656.encode('utf-8') if sys.version_info[0] == 2 else iter656)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_all_effective_roles_for_user_result)
get_all_effective_roles_for_user_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRING, 'UTF8', False), None, ),  # 0
    (1, TType.STRUCT, 'e', [TDBException, None], None, ),  # 1
)


class has_role_args(object):
    """
    Attributes:
     - session
     - granteeName
     - roleName

    """


    def __init__(self, session=None, granteeName=None, roleName=None,):
        self.session = session
        self.granteeName = granteeName
        self.roleName = roleName

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.session = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.granteeName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.roleName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('has_role_args')
        if self.session is not None:
            oprot.writeFieldBegin('session', TType.STRING, 1)
            oprot.writeString(self.session.encode('utf-8') if sys.version_info[0] == 2 else self.session)
            oprot.writeFieldEnd()
        if self.granteeName is not None:
            oprot.writeFieldBegin('granteeName', TType.STRING, 2)
            oprot.writeString(self.granteeName.encode('utf-8') if sys.version_info[0] == 2 else self.granteeName)
            oprot.writeFieldEnd()
        if self.roleName is not None:
            oprot.writeFieldBegin('roleName', TType.STRING, 3)
            oprot.writeString(self.roleName.encode('utf-8') if sys.version_info[0] == 2 else self.roleName)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(has_role_args)
has_role_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'session', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'granteeName', 'UTF8', None, ),  # 2
    (3, TType.STRING, 'roleName', 'UTF8', None, ),  # 3
)


class has_role_result(object):
    """
    Attributes:
     - success
     - e

    """


    def __init__(self, success=None, e=None,):
        self.success = success
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.BOOL:
                    self.success = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TDBException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('has_role_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.BOOL, 0)
            oprot.writeBool(self.success)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(has_role_result)
has_role_result.thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'e', [TDBException, None], None, ),  # 1
)


class has_object_privilege_args(object):
    """
    Attributes:
     - session
     - granteeName
     - ObjectName
     - objectType
     - permissions

    """


    def __init__(self, session=None, granteeName=None, ObjectName=None, objectType=None, permissions=None,):
        self.session = session
        self.granteeName = granteeName
        self.ObjectName = ObjectName
        self.objectType = objectType
        self.permissions = permissions

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.session = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.granteeName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.ObjectName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I32:
                    self.objectType = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRUCT:
                    self.permissions = TDBObjectPermissions()
                    self.permissions.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('has_object_privilege_args')
        if self.session is not None:
            oprot.writeFieldBegin('session', TType.STRING, 1)
            oprot.writeString(self.session.encode('utf-8') if sys.version_info[0] == 2 else self.session)
            oprot.writeFieldEnd()
        if self.granteeName is not None:
            oprot.writeFieldBegin('granteeName', TType.STRING, 2)
            oprot.writeString(self.granteeName.encode('utf-8') if sys.version_info[0] == 2 else self.granteeName)
            oprot.writeFieldEnd()
        if self.ObjectName is not None:
            oprot.writeFieldBegin('ObjectName', TType.STRING, 3)
            oprot.writeString(self.ObjectName.encode('utf-8') if sys.version_info[0] == 2 else self.ObjectName)
            oprot.writeFieldEnd()
        if self.objectType is not None:
            oprot.writeFieldBegin('objectType', TType.I32, 4)
            oprot.writeI32(self.objectType)
            oprot.writeFieldEnd()
        if self.permissions is not None:
            oprot.writeFieldBegin('permissions', TType.STRUCT, 5)
            self.permissions.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(has_object_privilege_args)
has_object_privilege_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'session', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'granteeName', 'UTF8', None, ),  # 2
    (3, TType.STRING, 'ObjectName', 'UTF8', None, ),  # 3
    (4, TType.I32, 'objectType', None, None, ),  # 4
    (5, TType.STRUCT, 'permissions', [TDBObjectPermissions, None], None, ),  # 5
)


class has_object_privilege_result(object):
    """
    Attributes:
     - success
     - e

    """


    def __init__(self, success=None, e=None,):
        self.success = success
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.BOOL:
                    self.success = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TDBException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('has_object_privilege_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.BOOL, 0)
            oprot.writeBool(self.success)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(has_object_privilege_result)
has_object_privilege_result.thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'e', [TDBException, None], None, ),  # 1
)


class set_license_key_args(object):
    """
    Attributes:
     - session
     - key
     - nonce

    """


    def __init__(self, session=None, key=None, nonce="",):
        self.session = session
        self.key = key
        self.nonce = nonce

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.session = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.key = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.nonce = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('set_license_key_args')
        if self.session is not None:
            oprot.writeFieldBegin('session', TType.STRING, 1)
            oprot.writeString(self.session.encode('utf-8') if sys.version_info[0] == 2 else self.session)
            oprot.writeFieldEnd()
        if self.key is not None:
            oprot.writeFieldBegin('key', TType.STRING, 2)
            oprot.writeString(self.key.encode('utf-8') if sys.version_info[0] == 2 else self.key)
            oprot.writeFieldEnd()
        if self.nonce is not None:
            oprot.writeFieldBegin('nonce', TType.STRING, 3)
            oprot.writeString(self.nonce.encode('utf-8') if sys.version_info[0] == 2 else self.nonce)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(set_license_key_args)
set_license_key_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'session', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'key', 'UTF8', None, ),  # 2
    (3, TType.STRING, 'nonce', 'UTF8', "", ),  # 3
)


class set_license_key_result(object):
    """
    Attributes:
     - success
     - e

    """


    def __init__(self, success=None, e=None,):
        self.success = success
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = TLicenseInfo()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TDBException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('set_license_key_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(set_license_key_result)
set_license_key_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [TLicenseInfo, None], None, ),  # 0
    (1, TType.STRUCT, 'e', [TDBException, None], None, ),  # 1
)


class get_license_claims_args(object):
    """
    Attributes:
     - session
     - nonce

    """


    def __init__(self, session=None, nonce="",):
        self.session = session
        self.nonce = nonce

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.session = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.nonce = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_license_claims_args')
        if self.session is not None:
            oprot.writeFieldBegin('session', TType.STRING, 1)
            oprot.writeString(self.session.encode('utf-8') if sys.version_info[0] == 2 else self.session)
            oprot.writeFieldEnd()
        if self.nonce is not None:
            oprot.writeFieldBegin('nonce', TType.STRING, 2)
            oprot.writeString(self.nonce.encode('utf-8') if sys.version_info[0] == 2 else self.nonce)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_license_claims_args)
get_license_claims_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'session', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'nonce', 'UTF8', "", ),  # 2
)


class get_license_claims_result(object):
    """
    Attributes:
     - success
     - e

    """


    def __init__(self, success=None, e=None,):
        self.success = success
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = TLicenseInfo()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TDBException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_license_claims_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_license_claims_result)
get_license_claims_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [TLicenseInfo, None], None, ),  # 0
    (1, TType.STRUCT, 'e', [TDBException, None], None, ),  # 1
)


class get_device_parameters_args(object):
    """
    Attributes:
     - session

    """


    def __init__(self, session=None,):
        self.session = session

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.session = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_device_parameters_args')
        if self.session is not None:
            oprot.writeFieldBegin('session', TType.STRING, 1)
            oprot.writeString(self.session.encode('utf-8') if sys.version_info[0] == 2 else self.session)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_device_parameters_args)
get_device_parameters_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'session', 'UTF8', None, ),  # 1
)


class get_device_parameters_result(object):
    """
    Attributes:
     - success
     - e

    """


    def __init__(self, success=None, e=None,):
        self.success = success
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.MAP:
                    self.success = {}
                    (_ktype658, _vtype659, _size657) = iprot.readMapBegin()
                    for _i661 in range(_size657):
                        _key662 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        _val663 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.success[_key662] = _val663
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TDBException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_device_parameters_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.MAP, 0)
            oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.success))
            for kiter664, viter665 in self.success.items():
                oprot.writeString(kiter664.encode('utf-8') if sys.version_info[0] == 2 else kiter664)
                oprot.writeString(viter665.encode('utf-8') if sys.version_info[0] == 2 else viter665)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_device_parameters_result)
get_device_parameters_result.thrift_spec = (
    (0, TType.MAP, 'success', (TType.STRING, 'UTF8', TType.STRING, 'UTF8', False), None, ),  # 0
    (1, TType.STRUCT, 'e', [TDBException, None], None, ),  # 1
)


class register_runtime_extension_functions_args(object):
    """
    Attributes:
     - session
     - udfs
     - udtfs
     - device_ir_map

    """


    def __init__(self, session=None, udfs=None, udtfs=None, device_ir_map=None,):
        self.session = session
        self.udfs = udfs
        self.udtfs = udtfs
        self.device_ir_map = device_ir_map

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.session = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.udfs = []
                    (_etype669, _size666) = iprot.readListBegin()
                    for _i670 in range(_size666):
                        _elem671 = heavydb.extension_functions.ttypes.TUserDefinedFunction()
                        _elem671.read(iprot)
                        self.udfs.append(_elem671)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.udtfs = []
                    (_etype675, _size672) = iprot.readListBegin()
                    for _i676 in range(_size672):
                        _elem677 = heavydb.extension_functions.ttypes.TUserDefinedTableFunction()
                        _elem677.read(iprot)
                        self.udtfs.append(_elem677)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.MAP:
                    self.device_ir_map = {}
                    (_ktype679, _vtype680, _size678) = iprot.readMapBegin()
                    for _i682 in range(_size678):
                        _key683 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        _val684 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.device_ir_map[_key683] = _val684
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('register_runtime_extension_functions_args')
        if self.session is not None:
            oprot.writeFieldBegin('session', TType.STRING, 1)
            oprot.writeString(self.session.encode('utf-8') if sys.version_info[0] == 2 else self.session)
            oprot.writeFieldEnd()
        if self.udfs is not None:
            oprot.writeFieldBegin('udfs', TType.LIST, 2)
            oprot.writeListBegin(TType.STRUCT, len(self.udfs))
            for iter685 in self.udfs:
                iter685.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.udtfs is not None:
            oprot.writeFieldBegin('udtfs', TType.LIST, 3)
            oprot.writeListBegin(TType.STRUCT, len(self.udtfs))
            for iter686 in self.udtfs:
                iter686.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.device_ir_map is not None:
            oprot.writeFieldBegin('device_ir_map', TType.MAP, 4)
            oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.device_ir_map))
            for kiter687, viter688 in self.device_ir_map.items():
                oprot.writeString(kiter687.encode('utf-8') if sys.version_info[0] == 2 else kiter687)
                oprot.writeString(viter688.encode('utf-8') if sys.version_info[0] == 2 else viter688)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(register_runtime_extension_functions_args)
register_runtime_extension_functions_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'session', 'UTF8', None, ),  # 1
    (2, TType.LIST, 'udfs', (TType.STRUCT, [heavydb.extension_functions.ttypes.TUserDefinedFunction, None], False), None,),  # 2
    (3, TType.LIST, 'udtfs', (TType.STRUCT, [heavydb.extension_functions.ttypes.TUserDefinedTableFunction, None], False), None,),  # 3
    (4, TType.MAP, 'device_ir_map', (TType.STRING, 'UTF8', TType.STRING, 'UTF8', False), None, ),  # 4
)


class register_runtime_extension_functions_result(object):
    """
    Attributes:
     - e

    """


    def __init__(self, e=None,):
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TDBException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('register_runtime_extension_functions_result')
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(register_runtime_extension_functions_result)
register_runtime_extension_functions_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'e', [TDBException, None], None, ),  # 1
)


class get_table_function_names_args(object):
    """
    Attributes:
     - session

    """


    def __init__(self, session=None,):
        self.session = session

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.session = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_table_function_names_args')
        if self.session is not None:
            oprot.writeFieldBegin('session', TType.STRING, 1)
            oprot.writeString(self.session.encode('utf-8') if sys.version_info[0] == 2 else self.session)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_table_function_names_args)
get_table_function_names_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'session', 'UTF8', None, ),  # 1
)


class get_table_function_names_result(object):
    """
    Attributes:
     - success
     - e

    """


    def __init__(self, success=None, e=None,):
        self.success = success
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype692, _size689) = iprot.readListBegin()
                    for _i693 in range(_size689):
                        _elem694 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.success.append(_elem694)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TDBException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_table_function_names_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRING, len(self.success))
            for iter695 in self.success:
                oprot.writeString(iter695.encode('utf-8') if sys.version_info[0] == 2 else iter695)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_table_function_names_result)
get_table_function_names_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRING, 'UTF8', False), None, ),  # 0
    (1, TType.STRUCT, 'e', [TDBException, None], None, ),  # 1
)


class get_runtime_table_function_names_args(object):
    """
    Attributes:
     - session

    """


    def __init__(self, session=None,):
        self.session = session

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.session = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_runtime_table_function_names_args')
        if self.session is not None:
            oprot.writeFieldBegin('session', TType.STRING, 1)
            oprot.writeString(self.session.encode('utf-8') if sys.version_info[0] == 2 else self.session)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_runtime_table_function_names_args)
get_runtime_table_function_names_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'session', 'UTF8', None, ),  # 1
)


class get_runtime_table_function_names_result(object):
    """
    Attributes:
     - success
     - e

    """


    def __init__(self, success=None, e=None,):
        self.success = success
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype699, _size696) = iprot.readListBegin()
                    for _i700 in range(_size696):
                        _elem701 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.success.append(_elem701)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TDBException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_runtime_table_function_names_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRING, len(self.success))
            for iter702 in self.success:
                oprot.writeString(iter702.encode('utf-8') if sys.version_info[0] == 2 else iter702)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_runtime_table_function_names_result)
get_runtime_table_function_names_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRING, 'UTF8', False), None, ),  # 0
    (1, TType.STRUCT, 'e', [TDBException, None], None, ),  # 1
)


class get_table_function_details_args(object):
    """
    Attributes:
     - session
     - udtf_names

    """


    def __init__(self, session=None, udtf_names=None,):
        self.session = session
        self.udtf_names = udtf_names

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.session = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.udtf_names = []
                    (_etype706, _size703) = iprot.readListBegin()
                    for _i707 in range(_size703):
                        _elem708 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.udtf_names.append(_elem708)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_table_function_details_args')
        if self.session is not None:
            oprot.writeFieldBegin('session', TType.STRING, 1)
            oprot.writeString(self.session.encode('utf-8') if sys.version_info[0] == 2 else self.session)
            oprot.writeFieldEnd()
        if self.udtf_names is not None:
            oprot.writeFieldBegin('udtf_names', TType.LIST, 2)
            oprot.writeListBegin(TType.STRING, len(self.udtf_names))
            for iter709 in self.udtf_names:
                oprot.writeString(iter709.encode('utf-8') if sys.version_info[0] == 2 else iter709)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_table_function_details_args)
get_table_function_details_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'session', 'UTF8', None, ),  # 1
    (2, TType.LIST, 'udtf_names', (TType.STRING, 'UTF8', False), None, ),  # 2
)


class get_table_function_details_result(object):
    """
    Attributes:
     - success
     - e

    """


    def __init__(self, success=None, e=None,):
        self.success = success
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype713, _size710) = iprot.readListBegin()
                    for _i714 in range(_size710):
                        _elem715 = heavydb.extension_functions.ttypes.TUserDefinedTableFunction()
                        _elem715.read(iprot)
                        self.success.append(_elem715)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TDBException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_table_function_details_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter716 in self.success:
                iter716.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_table_function_details_result)
get_table_function_details_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT, [heavydb.extension_functions.ttypes.TUserDefinedTableFunction, None], False), None,),  # 0
    (1, TType.STRUCT, 'e', [TDBException, None], None, ),  # 1
)
fix_spec(all_structs)
del all_structs
