#
# Autogenerated by Thrift Compiler (0.15.0)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py
#

from thrift.Thrift import TType, TMessageType, TFrozenDict, TException, TApplicationException
from thrift.protocol.TProtocol import TProtocolException
from thrift.TRecursive import fix_spec

import sys
import heavydb.common.ttypes

from thrift.transport import TTransport
all_structs = []


class TResultSetLayout(object):
    GroupByPerfectHash = 0
    GroupByBaselineHash = 1
    Projection = 2
    NonGroupedAggregate = 3

    _VALUES_TO_NAMES = {
        0: "GroupByPerfectHash",
        1: "GroupByBaselineHash",
        2: "Projection",
        3: "NonGroupedAggregate",
    }

    _NAMES_TO_VALUES = {
        "GroupByPerfectHash": 0,
        "GroupByBaselineHash": 1,
        "Projection": 2,
        "NonGroupedAggregate": 3,
    }


class TCountDistinctImplType(object):
    Invalid = 0
    Bitmap = 1
    UnorderedSet = 2

    _VALUES_TO_NAMES = {
        0: "Invalid",
        1: "Bitmap",
        2: "UnorderedSet",
    }

    _NAMES_TO_VALUES = {
        "Invalid": 0,
        "Bitmap": 1,
        "UnorderedSet": 2,
    }


class TAggKind(object):
    AVG = 0
    MIN = 1
    MAX = 2
    SUM = 3
    COUNT = 4
    APPROX_COUNT_DISTINCT = 5
    SAMPLE = 6
    SINGLE_VALUE = 7

    _VALUES_TO_NAMES = {
        0: "AVG",
        1: "MIN",
        2: "MAX",
        3: "SUM",
        4: "COUNT",
        5: "APPROX_COUNT_DISTINCT",
        6: "SAMPLE",
        7: "SINGLE_VALUE",
    }

    _NAMES_TO_VALUES = {
        "AVG": 0,
        "MIN": 1,
        "MAX": 2,
        "SUM": 3,
        "COUNT": 4,
        "APPROX_COUNT_DISTINCT": 5,
        "SAMPLE": 6,
        "SINGLE_VALUE": 7,
    }


class TSlotSize(object):
    """
    Attributes:
     - padded
     - logical

    """


    def __init__(self, padded=None, logical=None,):
        self.padded = padded
        self.logical = logical

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I16:
                    self.padded = iprot.readI16()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I16:
                    self.logical = iprot.readI16()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TSlotSize')
        if self.padded is not None:
            oprot.writeFieldBegin('padded', TType.I16, 1)
            oprot.writeI16(self.padded)
            oprot.writeFieldEnd()
        if self.logical is not None:
            oprot.writeFieldBegin('logical', TType.I16, 2)
            oprot.writeI16(self.logical)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TColSlotContext(object):
    """
    Attributes:
     - slot_sizes
     - col_to_slot_map

    """


    def __init__(self, slot_sizes=None, col_to_slot_map=None,):
        self.slot_sizes = slot_sizes
        self.col_to_slot_map = col_to_slot_map

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.slot_sizes = []
                    (_etype3, _size0) = iprot.readListBegin()
                    for _i4 in range(_size0):
                        _elem5 = TSlotSize()
                        _elem5.read(iprot)
                        self.slot_sizes.append(_elem5)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.col_to_slot_map = []
                    (_etype9, _size6) = iprot.readListBegin()
                    for _i10 in range(_size6):
                        _elem11 = []
                        (_etype15, _size12) = iprot.readListBegin()
                        for _i16 in range(_size12):
                            _elem17 = iprot.readI32()
                            _elem11.append(_elem17)
                        iprot.readListEnd()
                        self.col_to_slot_map.append(_elem11)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TColSlotContext')
        if self.slot_sizes is not None:
            oprot.writeFieldBegin('slot_sizes', TType.LIST, 1)
            oprot.writeListBegin(TType.STRUCT, len(self.slot_sizes))
            for iter18 in self.slot_sizes:
                iter18.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.col_to_slot_map is not None:
            oprot.writeFieldBegin('col_to_slot_map', TType.LIST, 2)
            oprot.writeListBegin(TType.LIST, len(self.col_to_slot_map))
            for iter19 in self.col_to_slot_map:
                oprot.writeListBegin(TType.I32, len(iter19))
                for iter20 in iter19:
                    oprot.writeI32(iter20)
                oprot.writeListEnd()
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TCountDistinctDescriptor(object):
    """
    Attributes:
     - impl_type
     - min_val
     - bitmap_sz_bits
     - approximate
     - device_type
     - sub_bitmap_count

    """


    def __init__(self, impl_type=None, min_val=None, bitmap_sz_bits=None, approximate=None, device_type=None, sub_bitmap_count=None,):
        self.impl_type = impl_type
        self.min_val = min_val
        self.bitmap_sz_bits = bitmap_sz_bits
        self.approximate = approximate
        self.device_type = device_type
        self.sub_bitmap_count = sub_bitmap_count

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.impl_type = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.min_val = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I64:
                    self.bitmap_sz_bits = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.BOOL:
                    self.approximate = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.I32:
                    self.device_type = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.I64:
                    self.sub_bitmap_count = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TCountDistinctDescriptor')
        if self.impl_type is not None:
            oprot.writeFieldBegin('impl_type', TType.I32, 1)
            oprot.writeI32(self.impl_type)
            oprot.writeFieldEnd()
        if self.min_val is not None:
            oprot.writeFieldBegin('min_val', TType.I64, 2)
            oprot.writeI64(self.min_val)
            oprot.writeFieldEnd()
        if self.bitmap_sz_bits is not None:
            oprot.writeFieldBegin('bitmap_sz_bits', TType.I64, 3)
            oprot.writeI64(self.bitmap_sz_bits)
            oprot.writeFieldEnd()
        if self.approximate is not None:
            oprot.writeFieldBegin('approximate', TType.BOOL, 4)
            oprot.writeBool(self.approximate)
            oprot.writeFieldEnd()
        if self.device_type is not None:
            oprot.writeFieldBegin('device_type', TType.I32, 5)
            oprot.writeI32(self.device_type)
            oprot.writeFieldEnd()
        if self.sub_bitmap_count is not None:
            oprot.writeFieldBegin('sub_bitmap_count', TType.I64, 6)
            oprot.writeI64(self.sub_bitmap_count)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TResultSetBufferDescriptor(object):
    """
    Attributes:
     - layout
     - keyless
     - entry_count
     - idx_target_as_key
     - min_val
     - max_val
     - bucket
     - group_col_widths
     - key_bytewidth
     - col_slot_context
     - target_groupby_indices
     - count_distinct_descriptors
     - force_4byte_float

    """


    def __init__(self, layout=None, keyless=None, entry_count=None, idx_target_as_key=None, min_val=None, max_val=None, bucket=None, group_col_widths=None, key_bytewidth=None, col_slot_context=None, target_groupby_indices=None, count_distinct_descriptors=None, force_4byte_float=None,):
        self.layout = layout
        self.keyless = keyless
        self.entry_count = entry_count
        self.idx_target_as_key = idx_target_as_key
        self.min_val = min_val
        self.max_val = max_val
        self.bucket = bucket
        self.group_col_widths = group_col_widths
        self.key_bytewidth = key_bytewidth
        self.col_slot_context = col_slot_context
        self.target_groupby_indices = target_groupby_indices
        self.count_distinct_descriptors = count_distinct_descriptors
        self.force_4byte_float = force_4byte_float

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.layout = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.BOOL:
                    self.keyless = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.entry_count = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I32:
                    self.idx_target_as_key = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.I64:
                    self.min_val = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.I64:
                    self.max_val = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.I64:
                    self.bucket = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 8:
                if ftype == TType.LIST:
                    self.group_col_widths = []
                    (_etype24, _size21) = iprot.readListBegin()
                    for _i25 in range(_size21):
                        _elem26 = iprot.readI16()
                        self.group_col_widths.append(_elem26)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 9:
                if ftype == TType.I16:
                    self.key_bytewidth = iprot.readI16()
                else:
                    iprot.skip(ftype)
            elif fid == 10:
                if ftype == TType.STRUCT:
                    self.col_slot_context = TColSlotContext()
                    self.col_slot_context.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 11:
                if ftype == TType.LIST:
                    self.target_groupby_indices = []
                    (_etype30, _size27) = iprot.readListBegin()
                    for _i31 in range(_size27):
                        _elem32 = iprot.readI32()
                        self.target_groupby_indices.append(_elem32)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 12:
                if ftype == TType.LIST:
                    self.count_distinct_descriptors = []
                    (_etype36, _size33) = iprot.readListBegin()
                    for _i37 in range(_size33):
                        _elem38 = TCountDistinctDescriptor()
                        _elem38.read(iprot)
                        self.count_distinct_descriptors.append(_elem38)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 13:
                if ftype == TType.BOOL:
                    self.force_4byte_float = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TResultSetBufferDescriptor')
        if self.layout is not None:
            oprot.writeFieldBegin('layout', TType.I32, 1)
            oprot.writeI32(self.layout)
            oprot.writeFieldEnd()
        if self.keyless is not None:
            oprot.writeFieldBegin('keyless', TType.BOOL, 2)
            oprot.writeBool(self.keyless)
            oprot.writeFieldEnd()
        if self.entry_count is not None:
            oprot.writeFieldBegin('entry_count', TType.I32, 3)
            oprot.writeI32(self.entry_count)
            oprot.writeFieldEnd()
        if self.idx_target_as_key is not None:
            oprot.writeFieldBegin('idx_target_as_key', TType.I32, 4)
            oprot.writeI32(self.idx_target_as_key)
            oprot.writeFieldEnd()
        if self.min_val is not None:
            oprot.writeFieldBegin('min_val', TType.I64, 5)
            oprot.writeI64(self.min_val)
            oprot.writeFieldEnd()
        if self.max_val is not None:
            oprot.writeFieldBegin('max_val', TType.I64, 6)
            oprot.writeI64(self.max_val)
            oprot.writeFieldEnd()
        if self.bucket is not None:
            oprot.writeFieldBegin('bucket', TType.I64, 7)
            oprot.writeI64(self.bucket)
            oprot.writeFieldEnd()
        if self.group_col_widths is not None:
            oprot.writeFieldBegin('group_col_widths', TType.LIST, 8)
            oprot.writeListBegin(TType.I16, len(self.group_col_widths))
            for iter39 in self.group_col_widths:
                oprot.writeI16(iter39)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.key_bytewidth is not None:
            oprot.writeFieldBegin('key_bytewidth', TType.I16, 9)
            oprot.writeI16(self.key_bytewidth)
            oprot.writeFieldEnd()
        if self.col_slot_context is not None:
            oprot.writeFieldBegin('col_slot_context', TType.STRUCT, 10)
            self.col_slot_context.write(oprot)
            oprot.writeFieldEnd()
        if self.target_groupby_indices is not None:
            oprot.writeFieldBegin('target_groupby_indices', TType.LIST, 11)
            oprot.writeListBegin(TType.I32, len(self.target_groupby_indices))
            for iter40 in self.target_groupby_indices:
                oprot.writeI32(iter40)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.count_distinct_descriptors is not None:
            oprot.writeFieldBegin('count_distinct_descriptors', TType.LIST, 12)
            oprot.writeListBegin(TType.STRUCT, len(self.count_distinct_descriptors))
            for iter41 in self.count_distinct_descriptors:
                iter41.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.force_4byte_float is not None:
            oprot.writeFieldBegin('force_4byte_float', TType.BOOL, 13)
            oprot.writeBool(self.force_4byte_float)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TTargetInfo(object):
    """
    Attributes:
     - is_agg
     - kind
     - type
     - arg_type
     - skip_nulls
     - is_distinct

    """


    def __init__(self, is_agg=None, kind=None, type=None, arg_type=None, skip_nulls=None, is_distinct=None,):
        self.is_agg = is_agg
        self.kind = kind
        self.type = type
        self.arg_type = arg_type
        self.skip_nulls = skip_nulls
        self.is_distinct = is_distinct

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.BOOL:
                    self.is_agg = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.kind = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.type = heavydb.common.ttypes.TTypeInfo()
                    self.type.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.arg_type = heavydb.common.ttypes.TTypeInfo()
                    self.arg_type.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.BOOL:
                    self.skip_nulls = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.BOOL:
                    self.is_distinct = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TTargetInfo')
        if self.is_agg is not None:
            oprot.writeFieldBegin('is_agg', TType.BOOL, 1)
            oprot.writeBool(self.is_agg)
            oprot.writeFieldEnd()
        if self.kind is not None:
            oprot.writeFieldBegin('kind', TType.I32, 2)
            oprot.writeI32(self.kind)
            oprot.writeFieldEnd()
        if self.type is not None:
            oprot.writeFieldBegin('type', TType.STRUCT, 3)
            self.type.write(oprot)
            oprot.writeFieldEnd()
        if self.arg_type is not None:
            oprot.writeFieldBegin('arg_type', TType.STRUCT, 4)
            self.arg_type.write(oprot)
            oprot.writeFieldEnd()
        if self.skip_nulls is not None:
            oprot.writeFieldBegin('skip_nulls', TType.BOOL, 5)
            oprot.writeBool(self.skip_nulls)
            oprot.writeFieldEnd()
        if self.is_distinct is not None:
            oprot.writeFieldBegin('is_distinct', TType.BOOL, 6)
            oprot.writeBool(self.is_distinct)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TCountDistinctSetStorage(object):
    """
    Attributes:
     - bitmap
     - sparse_set

    """


    def __init__(self, bitmap=None, sparse_set=None,):
        self.bitmap = bitmap
        self.sparse_set = sparse_set

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.bitmap = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.SET:
                    self.sparse_set = set()
                    (_etype45, _size42) = iprot.readSetBegin()
                    for _i46 in range(_size42):
                        _elem47 = iprot.readI64()
                        self.sparse_set.add(_elem47)
                    iprot.readSetEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TCountDistinctSetStorage')
        if self.bitmap is not None:
            oprot.writeFieldBegin('bitmap', TType.STRING, 1)
            oprot.writeBinary(self.bitmap)
            oprot.writeFieldEnd()
        if self.sparse_set is not None:
            oprot.writeFieldBegin('sparse_set', TType.SET, 2)
            oprot.writeSetBegin(TType.I64, len(self.sparse_set))
            for iter48 in self.sparse_set:
                oprot.writeI64(iter48)
            oprot.writeSetEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TCountDistinctSet(object):
    """
    Attributes:
     - type
     - storage
     - remote_ptr

    """


    def __init__(self, type=None, storage=None, remote_ptr=None,):
        self.type = type
        self.storage = storage
        self.remote_ptr = remote_ptr

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.type = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.storage = TCountDistinctSetStorage()
                    self.storage.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I64:
                    self.remote_ptr = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TCountDistinctSet')
        if self.type is not None:
            oprot.writeFieldBegin('type', TType.I32, 1)
            oprot.writeI32(self.type)
            oprot.writeFieldEnd()
        if self.storage is not None:
            oprot.writeFieldBegin('storage', TType.STRUCT, 2)
            self.storage.write(oprot)
            oprot.writeFieldEnd()
        if self.remote_ptr is not None:
            oprot.writeFieldBegin('remote_ptr', TType.I64, 3)
            oprot.writeI64(self.remote_ptr)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TSerializedRows(object):
    """
    Attributes:
     - buffers
     - buffer_lengths
     - buffers_total_size
     - total_compression_time_ms
     - descriptor
     - targets
     - target_init_vals
     - varlen_buffer
     - count_distinct_sets
     - explanation

    """


    def __init__(self, buffers=None, buffer_lengths=None, buffers_total_size=None, total_compression_time_ms=None, descriptor=None, targets=None, target_init_vals=None, varlen_buffer=None, count_distinct_sets=None, explanation=None,):
        self.buffers = buffers
        self.buffer_lengths = buffer_lengths
        self.buffers_total_size = buffers_total_size
        self.total_compression_time_ms = total_compression_time_ms
        self.descriptor = descriptor
        self.targets = targets
        self.target_init_vals = target_init_vals
        self.varlen_buffer = varlen_buffer
        self.count_distinct_sets = count_distinct_sets
        self.explanation = explanation

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.buffers = []
                    (_etype52, _size49) = iprot.readListBegin()
                    for _i53 in range(_size49):
                        _elem54 = iprot.readBinary()
                        self.buffers.append(_elem54)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.buffer_lengths = []
                    (_etype58, _size55) = iprot.readListBegin()
                    for _i59 in range(_size55):
                        _elem60 = iprot.readI64()
                        self.buffer_lengths.append(_elem60)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I64:
                    self.buffers_total_size = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I32:
                    self.total_compression_time_ms = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRUCT:
                    self.descriptor = TResultSetBufferDescriptor()
                    self.descriptor.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.LIST:
                    self.targets = []
                    (_etype64, _size61) = iprot.readListBegin()
                    for _i65 in range(_size61):
                        _elem66 = TTargetInfo()
                        _elem66.read(iprot)
                        self.targets.append(_elem66)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.LIST:
                    self.target_init_vals = []
                    (_etype70, _size67) = iprot.readListBegin()
                    for _i71 in range(_size67):
                        _elem72 = iprot.readI64()
                        self.target_init_vals.append(_elem72)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 8:
                if ftype == TType.LIST:
                    self.varlen_buffer = []
                    (_etype76, _size73) = iprot.readListBegin()
                    for _i77 in range(_size73):
                        _elem78 = iprot.readBinary()
                        self.varlen_buffer.append(_elem78)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 9:
                if ftype == TType.LIST:
                    self.count_distinct_sets = []
                    (_etype82, _size79) = iprot.readListBegin()
                    for _i83 in range(_size79):
                        _elem84 = TCountDistinctSet()
                        _elem84.read(iprot)
                        self.count_distinct_sets.append(_elem84)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 10:
                if ftype == TType.STRING:
                    self.explanation = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TSerializedRows')
        if self.buffers is not None:
            oprot.writeFieldBegin('buffers', TType.LIST, 1)
            oprot.writeListBegin(TType.STRING, len(self.buffers))
            for iter85 in self.buffers:
                oprot.writeBinary(iter85)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.buffer_lengths is not None:
            oprot.writeFieldBegin('buffer_lengths', TType.LIST, 2)
            oprot.writeListBegin(TType.I64, len(self.buffer_lengths))
            for iter86 in self.buffer_lengths:
                oprot.writeI64(iter86)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.buffers_total_size is not None:
            oprot.writeFieldBegin('buffers_total_size', TType.I64, 3)
            oprot.writeI64(self.buffers_total_size)
            oprot.writeFieldEnd()
        if self.total_compression_time_ms is not None:
            oprot.writeFieldBegin('total_compression_time_ms', TType.I32, 4)
            oprot.writeI32(self.total_compression_time_ms)
            oprot.writeFieldEnd()
        if self.descriptor is not None:
            oprot.writeFieldBegin('descriptor', TType.STRUCT, 5)
            self.descriptor.write(oprot)
            oprot.writeFieldEnd()
        if self.targets is not None:
            oprot.writeFieldBegin('targets', TType.LIST, 6)
            oprot.writeListBegin(TType.STRUCT, len(self.targets))
            for iter87 in self.targets:
                iter87.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.target_init_vals is not None:
            oprot.writeFieldBegin('target_init_vals', TType.LIST, 7)
            oprot.writeListBegin(TType.I64, len(self.target_init_vals))
            for iter88 in self.target_init_vals:
                oprot.writeI64(iter88)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.varlen_buffer is not None:
            oprot.writeFieldBegin('varlen_buffer', TType.LIST, 8)
            oprot.writeListBegin(TType.STRING, len(self.varlen_buffer))
            for iter89 in self.varlen_buffer:
                oprot.writeBinary(iter89)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.count_distinct_sets is not None:
            oprot.writeFieldBegin('count_distinct_sets', TType.LIST, 9)
            oprot.writeListBegin(TType.STRUCT, len(self.count_distinct_sets))
            for iter90 in self.count_distinct_sets:
                iter90.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.explanation is not None:
            oprot.writeFieldBegin('explanation', TType.STRING, 10)
            oprot.writeString(self.explanation.encode('utf-8') if sys.version_info[0] == 2 else self.explanation)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(TSlotSize)
TSlotSize.thrift_spec = (
    None,  # 0
    (1, TType.I16, 'padded', None, None, ),  # 1
    (2, TType.I16, 'logical', None, None, ),  # 2
)
all_structs.append(TColSlotContext)
TColSlotContext.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'slot_sizes', (TType.STRUCT, [TSlotSize, None], False), None, ),  # 1
    (2, TType.LIST, 'col_to_slot_map', (TType.LIST, (TType.I32, None, False), False), None, ),  # 2
)
all_structs.append(TCountDistinctDescriptor)
TCountDistinctDescriptor.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'impl_type', None, None, ),  # 1
    (2, TType.I64, 'min_val', None, None, ),  # 2
    (3, TType.I64, 'bitmap_sz_bits', None, None, ),  # 3
    (4, TType.BOOL, 'approximate', None, None, ),  # 4
    (5, TType.I32, 'device_type', None, None, ),  # 5
    (6, TType.I64, 'sub_bitmap_count', None, None, ),  # 6
)
all_structs.append(TResultSetBufferDescriptor)
TResultSetBufferDescriptor.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'layout', None, None, ),  # 1
    (2, TType.BOOL, 'keyless', None, None, ),  # 2
    (3, TType.I32, 'entry_count', None, None, ),  # 3
    (4, TType.I32, 'idx_target_as_key', None, None, ),  # 4
    (5, TType.I64, 'min_val', None, None, ),  # 5
    (6, TType.I64, 'max_val', None, None, ),  # 6
    (7, TType.I64, 'bucket', None, None, ),  # 7
    (8, TType.LIST, 'group_col_widths', (TType.I16, None, False), None, ),  # 8
    (9, TType.I16, 'key_bytewidth', None, None, ),  # 9
    (10, TType.STRUCT, 'col_slot_context', [TColSlotContext, None], None, ),  # 10
    (11, TType.LIST, 'target_groupby_indices', (TType.I32, None, False), None, ),  # 11
    (12, TType.LIST, 'count_distinct_descriptors', (TType.STRUCT, [TCountDistinctDescriptor, None], False), None, ),  # 12
    (13, TType.BOOL, 'force_4byte_float', None, None, ),  # 13
)
all_structs.append(TTargetInfo)
TTargetInfo.thrift_spec = (
    None,  # 0
    (1, TType.BOOL, 'is_agg', None, None, ),  # 1
    (2, TType.I32, 'kind', None, None, ),  # 2
    (3, TType.STRUCT, 'type', [heavydb.common.ttypes.TTypeInfo, None], None,),  # 3
    (4, TType.STRUCT, 'arg_type', [heavydb.common.ttypes.TTypeInfo, None], None,),  # 4
    (5, TType.BOOL, 'skip_nulls', None, None, ),  # 5
    (6, TType.BOOL, 'is_distinct', None, None, ),  # 6
)
all_structs.append(TCountDistinctSetStorage)
TCountDistinctSetStorage.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'bitmap', 'BINARY', None, ),  # 1
    (2, TType.SET, 'sparse_set', (TType.I64, None, False), None, ),  # 2
)
all_structs.append(TCountDistinctSet)
TCountDistinctSet.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'type', None, None, ),  # 1
    (2, TType.STRUCT, 'storage', [TCountDistinctSetStorage, None], None, ),  # 2
    (3, TType.I64, 'remote_ptr', None, None, ),  # 3
)
all_structs.append(TSerializedRows)
TSerializedRows.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'buffers', (TType.STRING, 'BINARY', False), None, ),  # 1
    (2, TType.LIST, 'buffer_lengths', (TType.I64, None, False), None, ),  # 2
    (3, TType.I64, 'buffers_total_size', None, None, ),  # 3
    (4, TType.I32, 'total_compression_time_ms', None, None, ),  # 4
    (5, TType.STRUCT, 'descriptor', [TResultSetBufferDescriptor, None], None, ),  # 5
    (6, TType.LIST, 'targets', (TType.STRUCT, [TTargetInfo, None], False), None, ),  # 6
    (7, TType.LIST, 'target_init_vals', (TType.I64, None, False), None, ),  # 7
    (8, TType.LIST, 'varlen_buffer', (TType.STRING, 'BINARY', False), None, ),  # 8
    (9, TType.LIST, 'count_distinct_sets', (TType.STRUCT, [TCountDistinctSet, None], False), None, ),  # 9
    (10, TType.STRING, 'explanation', 'UTF8', None, ),  # 10
)
fix_spec(all_structs)
del all_structs
